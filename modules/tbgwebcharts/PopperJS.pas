unit PopperJS;

interface

uses Interfaces, Classes;

type
  TPopperJS = class(TInterfacedObject,iModelJS)
    private
      FPack : TStringList;
      FCDN: boolean;
    public
      constructor Create;
      destructor Destroy; override;
      class function New : iModelJS;
      function PackJS : String;
      function CDN(Value : Boolean) : iModelJS;
      function Credenciais(Value : iModelCredenciais) : iModelJS;
      procedure PopperJS_1;
      procedure PopperJS_2;
      procedure PopperJS_3;
      procedure PopperJS_4;
      procedure PopperJS_5;
      procedure PopperJS_6;
      procedure PopperJS_7;
      procedure PopperJS_8;
  end;

implementation

uses
  SysUtils;

{ TPopperJS }

function TPopperJS.CDN(Value: Boolean): iModelJS;
begin
  Result := Self;
  FCDN := Value;
end;

constructor TPopperJS.Create;
begin
  FPack := TStringList.Create;
end;

function TPopperJS.Credenciais(Value: iModelCredenciais): iModelJS;
begin
  Result := Self;
end;

destructor TPopperJS.Destroy;
begin
  freeandnil(fpack);
  inherited;
end;

class function TPopperJS.New: iModelJS;
begin
  Result := Self.Create;
end;

procedure TPopperJS.PopperJS_1;
begin
  FPack.Add('<script>'+#13);
  FPack.Add('/**!');
  FPack.Add(' * @fileOverview Kickass library to create and place poppers near their ');
  FPack.Add('reference elements.');
  FPack.Add(' * @version 1.12.9');
  FPack.Add(' * @license');
  FPack.Add(' * Copyright (c) 2016 Federico Zivolo and contributors');
  FPack.Add(' *');
  FPack.Add(' * Permission is hereby granted, free of charge, to any person obtaining a copy');
  FPack.Add(' * of this software and associated documentation files (the "Software"), to deal');
  FPack.Add(' * in the Software without restriction, including without limitation the rights');
  FPack.Add(' * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell');
  FPack.Add(' * copies of the Software, and to permit persons to whom the Software is');
  FPack.Add(' * furnished to do so, subject to the following conditions:');
  FPack.Add(' *');
  FPack.Add(' * The above copyright notice and this permission notice shall be included in ');
  FPack.Add('all');
  FPack.Add(' * copies or substantial portions of the Software.');
  FPack.Add(' *');
  FPack.Add(' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR');
  FPack.Add(' * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,');
  FPack.Add(' * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE');
  FPack.Add(' * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER');
  FPack.Add(' * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,');
  FPack.Add(' * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE');
  FPack.Add(' * SOFTWARE.');
  FPack.Add(' */');
  FPack.Add('(function (global, factory) {');
  FPack.Add('	typeof exports === ''object'' && typeof module !== ''undefined'' ? module.exports ');
  FPack.Add('= factory() :');
  FPack.Add('	typeof define === ''function'' && define.amd ? define(factory) :');
  FPack.Add('	(global.Popper = factory());');
  FPack.Add('}(this, (function () { ''use strict'';');
  FPack.Add('');
  FPack.Add('var isBrowser = typeof window !== ''undefined'' && typeof document !== ');
  FPack.Add('''undefined'';');
  FPack.Add('var longerTimeoutBrowsers = [''Edge'', ''Trident'', ''Firefox''];');
  FPack.Add('var timeoutDuration = 0;');
  FPack.Add('for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {');
  FPack.Add('  if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {');
  FPack.Add('    timeoutDuration = 1;');
  FPack.Add('    break;');
  FPack.Add('  }');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('function microtaskDebounce(fn) {');
  FPack.Add('  var called = false;');
  FPack.Add('  return function () {');
  FPack.Add('    if (called) {');
  FPack.Add('      return;');
  FPack.Add('    }');
  FPack.Add('    called = true;');
  FPack.Add('    window.Promise.resolve().then(function () {');
  FPack.Add('      called = false;');
  FPack.Add('      fn();');
  FPack.Add('    });');
  FPack.Add('  };');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('function taskDebounce(fn) {');
  FPack.Add('  var scheduled = false;');
  FPack.Add('  return function () {');
  FPack.Add('    if (!scheduled) {');
  FPack.Add('      scheduled = true;');
  FPack.Add('      setTimeout(function () {');
  FPack.Add('        scheduled = false;');
  FPack.Add('        fn();');
  FPack.Add('      }, timeoutDuration);');
  FPack.Add('    }');
  FPack.Add('  };');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('var supportsMicroTasks = isBrowser && window.Promise;');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add('* Create a debounced version of a method, that''s asynchronously deferred');
  FPack.Add('* but called in the minimum time possible.');
  FPack.Add('*');
  FPack.Add('* @method');
  FPack.Add('* @memberof Popper.Utils');
  FPack.Add('* @argument {Function} fn');
  FPack.Add('* @returns {Function}');
  FPack.Add('*/');
  FPack.Add('var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * Check if the given variable is a function');
  FPack.Add(' * @method');
  FPack.Add(' * @memberof Popper.Utils');
  FPack.Add(' * @argument {Any} functionToCheck - variable to check');
  FPack.Add(' * @returns {Boolean} answer to: is a function?');
  FPack.Add(' */');
  FPack.Add('function isFunction(functionToCheck) {');
  FPack.Add('  var getType = {};');
  FPack.Add('  return functionToCheck && getType.toString.call(functionToCheck) === ');
  FPack.Add('''[object Function]'';');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * Get CSS computed property of the given element');
  FPack.Add(' * @method');
  FPack.Add(' * @memberof Popper.Utils');
  FPack.Add(' * @argument {Eement} element');
  FPack.Add(' * @argument {String} property');
  FPack.Add(' */');
  FPack.Add('function getStyleComputedProperty(element, property) {');
  FPack.Add('  if (element.nodeType !== 1) {');
  FPack.Add('    return [];');
  FPack.Add('  }');
  FPack.Add('  // NOTE: 1 DOM access here');
  FPack.Add('  var css = getComputedStyle(element, null);');
  FPack.Add('  return property ? css[property] : css;');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * Returns the parentNode or the host of the element');
  FPack.Add(' * @method');
  FPack.Add(' * @memberof Popper.Utils');
  FPack.Add(' * @argument {Element} element');
  FPack.Add(' * @returns {Element} parent');
  FPack.Add(' */');
  FPack.Add('function getParentNode(element) {');
  FPack.Add('  if (element.nodeName === ''HTML'') {');
  FPack.Add('    return element;');
  FPack.Add('  }');
  FPack.Add('  return element.parentNode || element.host;');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * Returns the scrolling parent of the given element');
  FPack.Add(' * @method');
  FPack.Add(' * @memberof Popper.Utils');
  FPack.Add(' * @argument {Element} element');
  FPack.Add(' * @returns {Element} scroll parent');
  FPack.Add(' */');
  FPack.Add('function getScrollParent(element) {');
  FPack.Add('  // Return body, `getScroll` will take care to get the correct `scrollTop` '
  + 'from it');
  FPack.Add('  if (!element) {');
  FPack.Add('    return document.body;');
  FPack.Add('  }');
  FPack.Add('');
  FPack.Add('  switch (element.nodeName) {');
  FPack.Add('    case ''HTML'':');
  FPack.Add('    case ''BODY'':');
  FPack.Add('      return element.ownerDocument.body;');
  FPack.Add('    case ''#document'':');
  FPack.Add('      return element.body;');
  FPack.Add('  }');
  FPack.Add('');
  FPack.Add('  // Firefox want us to check `-x` and `-y` variations as well');
  FPack.Add('');
  FPack.Add('  var _getStyleComputedProp = getStyleComputedProperty(element),');
  FPack.Add('      overflow = _getStyleComputedProp.overflow,');
  FPack.Add('      overflowX = _getStyleComputedProp.overflowX,');
  FPack.Add('      overflowY = _getStyleComputedProp.overflowY;');
  FPack.Add('');
  FPack.Add('  if (/(auto|scroll)/.test(overflow + overflowY + overflowX)) {');
  FPack.Add('    return element;');
  FPack.Add('  }');
  FPack.Add('');
  FPack.Add('  return getScrollParent(getParentNode(element));');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * Returns the offset parent of the given element');
  FPack.Add(' * @method');
  FPack.Add(' * @memberof Popper.Utils');
  FPack.Add(' * @argument {Element} element');
  FPack.Add(' * @returns {Element} offset parent');
  FPack.Add(' */');
  FPack.Add('function getOffsetParent(element) {');
  FPack.Add('  // NOTE: 1 DOM access here');
  FPack.Add('  var offsetParent = element && element.offsetParent;');
  FPack.Add('  var nodeName = offsetParent && offsetParent.nodeName;');
  FPack.Add('');
  FPack.Add('  if (!nodeName || nodeName === ''BODY'' || nodeName === ''HTML'') {');
  FPack.Add('    if (element) {');
  FPack.Add('      return element.ownerDocument.documentElement;');
  FPack.Add('    }');
  FPack.Add('');
  FPack.Add('    return document.documentElement;');
  FPack.Add('  }');
  FPack.Add('');
  FPack.Add('  // .offsetParent will return the closest TD or TABLE in case');
  FPack.Add('  // no offsetParent is present, I hate this job...');
  FPack.Add('  if ([''TD'', ''TABLE''].indexOf(offsetParent.nodeName) !== -1 && ');
  FPack.Add('getStyleComputedProperty(offsetParent, ''position'') === ''static'') {');
  FPack.Add('    return getOffsetParent(offsetParent);');
  FPack.Add('  }');
  FPack.Add('');
  FPack.Add('  return offsetParent;');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('function isOffsetContainer(element) {');
  FPack.Add('  var nodeName = element.nodeName;');
  FPack.Add('');
  FPack.Add('  if (nodeName === ''BODY'') {');
  FPack.Add('    return false;');
  FPack.Add('  }');
  FPack.Add('  return nodeName === ''HTML'' || getOffsetParent(element.firstElementChild) === ');
  FPack.Add('element;');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * Finds the root node (document, shadowDOM root) of the given element');
  FPack.Add(' * @method');
  FPack.Add(' * @memberof Popper.Utils');
  FPack.Add(' * @argument {Element} node');
  FPack.Add(' * @returns {Element} root node');
  FPack.Add(' */');
  FPack.Add('function getRoot(node) {');
  FPack.Add('  if (node.parentNode !== null) {');
  FPack.Add('    return getRoot(node.parentNode);');
  FPack.Add('  }');
  FPack.Add('');
  FPack.Add('  return node;');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * Finds the offset parent common to the two provided nodes');
  FPack.Add(' * @method');
  FPack.Add(' * @memberof Popper.Utils');
  FPack.Add(' * @argument {Element} element1');
  FPack.Add(' * @argument {Element} element2');
  FPack.Add(' * @returns {Element} common offset parent');
  FPack.Add(' */');
  FPack.Add('function findCommonOffsetParent(element1, element2) {');
  FPack.Add('  // This check is needed to avoid errors in case one of the elements isn''t defined for any reason');
  FPack.Add('  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {');
  FPack.Add('    return document.documentElement;');
  FPack.Add('  }');
  FPack.Add('');
  FPack.Add('  // Here we make sure to give as "start" the element that comes first in the ');
  FPack.Add('DOM');
  FPack.Add('  var order = element1.compareDocumentPosition(element2) & ');
  FPack.Add('Node.DOCUMENT_POSITION_FOLLOWING;');
  FPack.Add('  var start = order ? element1 : element2;');
  FPack.Add('  var end = order ? element2 : element1;');
  FPack.Add('');
  FPack.Add('  // Get common ancestor container');
  FPack.Add('  var range = document.createRange();');
  FPack.Add('  range.setStart(start, 0);');
  FPack.Add('  range.setEnd(end, 0);');
  FPack.Add('  var commonAncestorContainer = range.commonAncestorContainer;');
  FPack.Add('');
  FPack.Add('  // Both nodes are inside #document');
  FPack.Add('');
  FPack.Add('  if (element1 !== commonAncestorContainer && element2 !== ');
  FPack.Add('commonAncestorContainer || start.contains(end)) {');
  FPack.Add('    if (isOffsetContainer(commonAncestorContainer)) {');
  FPack.Add('      return commonAncestorContainer;');
  FPack.Add('    }');
  FPack.Add('');
  FPack.Add('    return getOffsetParent(commonAncestorContainer);');
  FPack.Add('  }');
  FPack.Add('');
  FPack.Add('  // one of the nodes is inside shadowDOM, find which one');
  FPack.Add('  var element1root = getRoot(element1);');
  FPack.Add('  if (element1root.host) {');
  FPack.Add('    return findCommonOffsetParent(element1root.host, element2);');
  FPack.Add('  } else {');
  FPack.Add('    return findCommonOffsetParent(element1, getRoot(element2).host);');
  FPack.Add('  }');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * Gets the scroll value of the given element in the given side (top and left)');
  FPack.Add(' * @method');
  FPack.Add(' * @memberof Popper.Utils');
  FPack.Add(' * @argument {Element} element');
  FPack.Add(' * @argument {String} side `top` or `left`');
  FPack.Add(' * @returns {number} amount of scrolled pixels');
  FPack.Add(' */');
  FPack.Add('function getScroll(element) {');
  FPack.Add('  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] ');
  FPack.Add(': ''top'';');
  FPack.Add('');
  FPack.Add('  var upperSide = side === ''top'' ? ''scrollTop'' : ''scrollLeft'';');
  FPack.Add('  var nodeName = element.nodeName;');
end;

procedure TPopperJS.PopperJS_2;
begin
  FPack.Add('');
  FPack.Add('  if (nodeName === ''BODY'' || nodeName === ''HTML'') {');
  FPack.Add('    var html = element.ownerDocument.documentElement;');
  FPack.Add('    var scrollingElement = element.ownerDocument.scrollingElement || html;');
  FPack.Add('    return scrollingElement[upperSide];');
  FPack.Add('  }');
  FPack.Add('');
  FPack.Add('  return element[upperSide];');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/*');
  FPack.Add(' * Sum or subtract the element scroll values (left and top) from a given rect ');
  FPack.Add('object');
  FPack.Add(' * @method');
  FPack.Add(' * @memberof Popper.Utils');
  FPack.Add(' * @param {Object} rect - Rect object you want to change');
  FPack.Add(' * @param {HTMLElement} element - The element from the function reads the ');
  FPack.Add('scroll values');
  FPack.Add(' * @param {Boolean} subtract - set to true if you want to subtract the scroll ');
  FPack.Add('values');
  FPack.Add(' * @return {Object} rect - The modifier rect object');
  FPack.Add(' */');
  FPack.Add('function includeScroll(rect, element) {');
  FPack.Add('  var subtract = arguments.length > 2 && arguments[2] !== undefined ? ');
  FPack.Add('arguments[2] : false;');
  FPack.Add('');
  FPack.Add('  var scrollTop = getScroll(element, ''top'');');
  FPack.Add('  var scrollLeft = getScroll(element, ''left'');');
  FPack.Add('  var modifier = subtract ? -1 : 1;');
  FPack.Add('  rect.top += scrollTop * modifier;');
  FPack.Add('  rect.bottom += scrollTop * modifier;');
  FPack.Add('  rect.left += scrollLeft * modifier;');
  FPack.Add('  rect.right += scrollLeft * modifier;');
  FPack.Add('  return rect;');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/*');
  FPack.Add(' * Helper to detect borders of a given element');
  FPack.Add(' * @method');
  FPack.Add(' * @memberof Popper.Utils');
  FPack.Add(' * @param {CSSStyleDeclaration} styles');
  FPack.Add(' * Result of `getStyleComputedProperty` on the given element');
  FPack.Add(' * @param {String} axis - `x` or `y`');
  FPack.Add(' * @return {number} borders - The borders size of the given axis');
  FPack.Add(' */');
  FPack.Add('');
  FPack.Add('function getBordersSize(styles, axis) {');
  FPack.Add('  var sideA = axis === ''x'' ? ''Left'' : ''Top'';');
  FPack.Add('  var sideB = sideA === ''Left'' ? ''Right'' : ''Bottom'';');
  FPack.Add('');
  FPack.Add('  return parseFloat(styles[''border'' + sideA + ''Width''], 10) + ');
  FPack.Add('parseFloat(styles[''border'' + sideB + ''Width''], 10);');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * Tells if you are running Internet Explorer 10');
  FPack.Add(' * @method');
  FPack.Add(' * @memberof Popper.Utils');
  FPack.Add(' * @returns {Boolean} isIE10');
  FPack.Add(' */');
  FPack.Add('var isIE10 = undefined;');
  FPack.Add('');
  FPack.Add('var isIE10$1 = function () {');
  FPack.Add('  if (isIE10 === undefined) {');
  FPack.Add('    isIE10 = navigator.appVersion.indexOf(''MSIE 10'') !== -1;');
  FPack.Add('  }');
  FPack.Add('  return isIE10;');
  FPack.Add('};');
  FPack.Add('');
  FPack.Add('function getSize(axis, body, html, computedStyle) {');
  FPack.Add('  return Math.max(body[''offset'' + axis], body[''scroll'' + axis], html[''client'' + ');
  FPack.Add('axis], html[''offset'' + axis], html[''scroll'' + axis], isIE10$1() ? html[''offset'' ');
  FPack.Add('+ axis] + computedStyle[''margin'' + (axis === ''Height'' ? ''Top'' : ''Left'')] + ');
  FPack.Add('computedStyle[''margin'' + (axis === ''Height'' ? ''Bottom'' : ''Right'')] : 0);');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('function getWindowSizes() {');
  FPack.Add('  var body = document.body;');
  FPack.Add('  var html = document.documentElement;');
  FPack.Add('  var computedStyle = isIE10$1() && getComputedStyle(html);');
  FPack.Add('');
  FPack.Add('  return {');
  FPack.Add('    height: getSize(''Height'', body, html, computedStyle),');
  FPack.Add('    width: getSize(''Width'', body, html, computedStyle)');
  FPack.Add('  };');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('var classCallCheck = function (instance, Constructor) {');
  FPack.Add('  if (!(instance instanceof Constructor)) {');
  FPack.Add('    throw new TypeError("Cannot call a class as a function");');
  FPack.Add('  }');
  FPack.Add('};');
  FPack.Add('');
  FPack.Add('var createClass = function () {');
  FPack.Add('  function defineProperties(target, props) {');
  FPack.Add('    for (var i = 0; i < props.length; i++) {');
  FPack.Add('      var descriptor = props[i];');
  FPack.Add('      descriptor.enumerable = descriptor.enumerable || false;');
  FPack.Add('      descriptor.configurable = true;');
  FPack.Add('      if ("value" in descriptor) descriptor.writable = true;');
  FPack.Add('      Object.defineProperty(target, descriptor.key, descriptor);');
  FPack.Add('    }');
  FPack.Add('  }');
  FPack.Add('');
  FPack.Add('  return function (Constructor, protoProps, staticProps) {');
  FPack.Add('    if (protoProps) defineProperties(Constructor.prototype, protoProps);');
  FPack.Add('    if (staticProps) defineProperties(Constructor, staticProps);');
  FPack.Add('    return Constructor;');
  FPack.Add('  };');
  FPack.Add('}();');
  FPack.Add('');
  FPack.Add('');
  FPack.Add('');
  FPack.Add('');
  FPack.Add('');
  FPack.Add('var defineProperty = function (obj, key, value) {');
  FPack.Add('  if (key in obj) {');
  FPack.Add('    Object.defineProperty(obj, key, {');
  FPack.Add('      value: value,');
  FPack.Add('      enumerable: true,');
  FPack.Add('      configurable: true,');
  FPack.Add('      writable: true');
  FPack.Add('    });');
  FPack.Add('  } else {');
  FPack.Add('    obj[key] = value;');
  FPack.Add('  }');
  FPack.Add('');
  FPack.Add('  return obj;');
  FPack.Add('};');
  FPack.Add('');
  FPack.Add('var _extends = Object.assign || function (target) {');
  FPack.Add('  for (var i = 1; i < arguments.length; i++) {');
  FPack.Add('    var source = arguments[i];');
  FPack.Add('');
  FPack.Add('    for (var key in source) {');
  FPack.Add('      if (Object.prototype.hasOwnProperty.call(source, key)) {');
  FPack.Add('        target[key] = source[key];');
  FPack.Add('      }');
  FPack.Add('    }');
  FPack.Add('  }');
  FPack.Add('');
  FPack.Add('  return target;');
  FPack.Add('};');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * Given element offsets, generate an output similar to getBoundingClientRect');
  FPack.Add(' * @method');
  FPack.Add(' * @memberof Popper.Utils');
  FPack.Add(' * @argument {Object} offsets');
  FPack.Add(' * @returns {Object} ClientRect like output');
  FPack.Add(' */');
  FPack.Add('function getClientRect(offsets) {');
  FPack.Add('  return _extends({}, offsets, {');
  FPack.Add('    right: offsets.left + offsets.width,');
  FPack.Add('    bottom: offsets.top + offsets.height');
  FPack.Add('  });');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * Get bounding client rect of given element');
  FPack.Add(' * @method');
  FPack.Add(' * @memberof Popper.Utils');
  FPack.Add(' * @param {HTMLElement} element');
  FPack.Add(' * @return {Object} client rect');
  FPack.Add(' */');
  FPack.Add('function getBoundingClientRect(element) {');
  FPack.Add('  var rect = {};');
  FPack.Add('');
  FPack.Add('  // IE10 10 FIX: Please, don''t ask, the element isn''t');
  FPack.Add('  // considered in DOM in some circumstances...');
  FPack.Add('  // This isn''t reproducible in IE10 compatibility mode of IE11');
  FPack.Add('  if (isIE10$1()) {');
  FPack.Add('    try {');
  FPack.Add('      rect = element.getBoundingClientRect();');
  FPack.Add('      var scrollTop = getScroll(element, ''top'');');
  FPack.Add('      var scrollLeft = getScroll(element, ''left'');');
  FPack.Add('      rect.top += scrollTop;');
  FPack.Add('      rect.left += scrollLeft;');
  FPack.Add('      rect.bottom += scrollTop;');
  FPack.Add('      rect.right += scrollLeft;');
  FPack.Add('    } catch (err) {}');
  FPack.Add('  } else {');
  FPack.Add('    rect = element.getBoundingClientRect();');
  FPack.Add('  }');
  FPack.Add('');
  FPack.Add('  var result = {');
  FPack.Add('    left: rect.left,');
  FPack.Add('    top: rect.top,');
  FPack.Add('    width: rect.right - rect.left,');
  FPack.Add('    height: rect.bottom - rect.top');
  FPack.Add('  };');
  FPack.Add('');
  FPack.Add('  // subtract scrollbar size from sizes');
  FPack.Add('  var sizes = element.nodeName === ''HTML'' ? getWindowSizes() : {};');
  FPack.Add('  var width = sizes.width || element.clientWidth || result.right - result.left;');
  FPack.Add('  var height = sizes.height || element.clientHeight || result.bottom - ');
  FPack.Add('result.top;');
  FPack.Add('');
  FPack.Add('  var horizScrollbar = element.offsetWidth - width;');
  FPack.Add('  var vertScrollbar = element.offsetHeight - height;');
  FPack.Add('');
  FPack.Add('  // if an hypothetical scrollbar is detected, we must be sure it''s not a `border`');
  FPack.Add('  // we make this check conditional for performance reasons');
  FPack.Add('  if (horizScrollbar || vertScrollbar) {');
  FPack.Add('    var styles = getStyleComputedProperty(element);');
  FPack.Add('    horizScrollbar -= getBordersSize(styles, ''x'');');
  FPack.Add('    vertScrollbar -= getBordersSize(styles, ''y'');');
  FPack.Add('');
  FPack.Add('    result.width -= horizScrollbar;');
  FPack.Add('    result.height -= vertScrollbar;');
  FPack.Add('  }');
  FPack.Add('');
  FPack.Add('  return getClientRect(result);');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('function getOffsetRectRelativeToArbitraryNode(children, parent) {');
  FPack.Add('  var isIE10 = isIE10$1();');
  FPack.Add('  var isHTML = parent.nodeName === ''HTML'';');
  FPack.Add('  var childrenRect = getBoundingClientRect(children);');
  FPack.Add('  var parentRect = getBoundingClientRect(parent);');
  FPack.Add('  var scrollParent = getScrollParent(children);');
  FPack.Add('');
  FPack.Add('  var styles = getStyleComputedProperty(parent);');
  FPack.Add('  var borderTopWidth = parseFloat(styles.borderTopWidth, 10);');
  FPack.Add('  var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);');
  FPack.Add('');
  FPack.Add('  var offsets = getClientRect({');
  FPack.Add('    top: childrenRect.top - parentRect.top - borderTopWidth,');
  FPack.Add('    left: childrenRect.left - parentRect.left - borderLeftWidth,');
  FPack.Add('    width: childrenRect.width,');
  FPack.Add('    height: childrenRect.height');
  FPack.Add('  });');
  FPack.Add('  offsets.marginTop = 0;');
  FPack.Add('  offsets.marginLeft = 0;');
  FPack.Add('');
  FPack.Add('  // Subtract margins of documentElement in case it''s being used as parent');
  FPack.Add('  // we do this only on HTML because it''s the only element that behaves');
  FPack.Add('  // differently when margins are applied to it. The margins are included in');
  FPack.Add('  // the box of the documentElement, in the other cases not.');
  FPack.Add('  if (!isIE10 && isHTML) {');
  FPack.Add('    var marginTop = parseFloat(styles.marginTop, 10);');
  FPack.Add('    var marginLeft = parseFloat(styles.marginLeft, 10);');
  FPack.Add('');
  FPack.Add('    offsets.top -= borderTopWidth - marginTop;');
  FPack.Add('    offsets.bottom -= borderTopWidth - marginTop;');
  FPack.Add('    offsets.left -= borderLeftWidth - marginLeft;');
  FPack.Add('    offsets.right -= borderLeftWidth - marginLeft;');
  FPack.Add('');
  FPack.Add('    // Attach marginTop and marginLeft because in some circumstances we may '
  + 'need them');
  FPack.Add('    offsets.marginTop = marginTop;');
  FPack.Add('    offsets.marginLeft = marginLeft;');
  FPack.Add('  }');
  FPack.Add('');
  FPack.Add('  if (isIE10 ? parent.contains(scrollParent) : parent === scrollParent && ');
  FPack.Add('scrollParent.nodeName !== ''BODY'') {');
  FPack.Add('    offsets = includeScroll(offsets, parent);');
  FPack.Add('  }');
  FPack.Add('');
  FPack.Add('  return offsets;');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('function getViewportOffsetRectRelativeToArtbitraryNode(element) {');
  FPack.Add('  var html = element.ownerDocument.documentElement;');
  FPack.Add('  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);');
  FPack.Add('  var width = Math.max(html.clientWidth, window.innerWidth || 0);');
  FPack.Add('  var height = Math.max(html.clientHeight, window.innerHeight || 0);');
  FPack.Add('');
  FPack.Add('  var scrollTop = getScroll(html);');
  FPack.Add('  var scrollLeft = getScroll(html, ''left'');');
  FPack.Add('');
  FPack.Add('  var offset = {');
  FPack.Add('    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,');
  FPack.Add('    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,');
  FPack.Add('    width: width,');
  FPack.Add('    height: height');
  FPack.Add('  };');
  FPack.Add('');
  FPack.Add('  return getClientRect(offset);');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * Check if the given element is fixed or is inside a fixed parent');
  FPack.Add(' * @method');
  FPack.Add(' * @memberof Popper.Utils');
  FPack.Add(' * @argument {Element} element');
  FPack.Add(' * @argument {Element} customContainer');
  FPack.Add(' * @returns {Boolean} answer to "isFixed?"');
  FPack.Add(' */');
  FPack.Add('function isFixed(element) {');
  FPack.Add('  var nodeName = element.nodeName;');
  FPack.Add('  if (nodeName === ''BODY'' || nodeName === ''HTML'') {');
  FPack.Add('    return false;');
  FPack.Add('  }');
  FPack.Add('  if (getStyleComputedProperty(element, ''position'') === ''fixed'') {');
  FPack.Add('    return true;');
  FPack.Add('  }');
  FPack.Add('  return isFixed(getParentNode(element));');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * Computed the boundaries limits and return them');
  FPack.Add(' * @method');
  FPack.Add(' * @memberof Popper.Utils');
  FPack.Add(' * @param {HTMLElement} popper');
  FPack.Add(' * @param {HTMLElement} reference');
  FPack.Add(' * @param {number} padding');
  FPack.Add(' * @param {HTMLElement} boundariesElement - Element used to define the ');
  FPack.Add('boundaries');
  FPack.Add(' * @returns {Object} Coordinates of the boundaries');
  FPack.Add(' */');
  FPack.Add('function getBoundaries(popper, reference, padding, boundariesElement) {');
  FPack.Add('  // NOTE: 1 DOM access here');
  FPack.Add('  var boundaries = { top: 0, left: 0 };');
  FPack.Add('  var offsetParent = findCommonOffsetParent(popper, reference);');
  FPack.Add('');
  FPack.Add('  // Handle viewport case');
  FPack.Add('  if (boundariesElement === ''viewport'') {');
  FPack.Add('    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent);');
  FPack.Add('  } else {');
  FPack.Add('    // Handle other cases based on DOM element used as boundaries');
  FPack.Add('    var boundariesNode = void 0;');
  FPack.Add('    if (boundariesElement === ''scrollParent'') {');
  FPack.Add('      boundariesNode = getScrollParent(getParentNode(reference));');
  FPack.Add('      if (boundariesNode.nodeName === ''BODY'') {');
  FPack.Add('        boundariesNode = popper.ownerDocument.documentElement;');
  FPack.Add('      }');
  FPack.Add('    } else if (boundariesElement === ''window'') {');
  FPack.Add('      boundariesNode = popper.ownerDocument.documentElement;');
  FPack.Add('    } else {');
  FPack.Add('      boundariesNode = boundariesElement;');
  FPack.Add('    }');
  FPack.Add('');
  FPack.Add('    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, ');
  FPack.Add('offsetParent);');
  FPack.Add('');
  FPack.Add('    // In case of HTML, we need a different computation');
end;

procedure TPopperJS.PopperJS_3;
begin
  FPack.Add('    if (boundariesNode.nodeName === ''HTML'' && !isFixed(offsetParent)) {');
  FPack.Add('      var _getWindowSizes = getWindowSizes(),');
  FPack.Add('          height = _getWindowSizes.height,');
  FPack.Add('          width = _getWindowSizes.width;');
  FPack.Add('');
  FPack.Add('      boundaries.top += offsets.top - offsets.marginTop;');
  FPack.Add('      boundaries.bottom = height + offsets.top;');
  FPack.Add('      boundaries.left += offsets.left - offsets.marginLeft;');
  FPack.Add('      boundaries.right = width + offsets.left;');
  FPack.Add('    } else {');
  FPack.Add('      // for all the other DOM elements, this one is good');
  FPack.Add('      boundaries = offsets;');
  FPack.Add('    }');
  FPack.Add('  }');
  FPack.Add('');
  FPack.Add('  // Add paddings');
  FPack.Add('  boundaries.left += padding;');
  FPack.Add('  boundaries.top += padding;');
  FPack.Add('  boundaries.right -= padding;');
  FPack.Add('  boundaries.bottom -= padding;');
  FPack.Add('');
  FPack.Add('  return boundaries;');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('function getArea(_ref) {');
  FPack.Add('  var width = _ref.width,');
  FPack.Add('      height = _ref.height;');
  FPack.Add('');
  FPack.Add('  return width * height;');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * Utility used to transform the `auto` placement to the placement with more');
  FPack.Add(' * available space.');
  FPack.Add(' * @method');
  FPack.Add(' * @memberof Popper.Utils');
  FPack.Add(' * @argument {Object} data - The data object generated by update method');
  FPack.Add(' * @argument {Object} options - Modifiers configuration and options');
  FPack.Add(' * @returns {Object} The data object, properly modified');
  FPack.Add(' */');
  FPack.Add('function computeAutoPlacement(placement, refRect, popper, reference, ');
  FPack.Add('boundariesElement) {');
  FPack.Add('  var padding = arguments.length > 5 && arguments[5] !== undefined ? ');
  FPack.Add('arguments[5] : 0;');
  FPack.Add('');
  FPack.Add('  if (placement.indexOf(''auto'') === -1) {');
  FPack.Add('    return placement;');
  FPack.Add('  }');
  FPack.Add('');
  FPack.Add('  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);');
  FPack.Add('');
  FPack.Add('  var rects = {');
  FPack.Add('    top: {');
  FPack.Add('      width: boundaries.width,');
  FPack.Add('      height: refRect.top - boundaries.top');
  FPack.Add('    },');
  FPack.Add('    right: {');
  FPack.Add('      width: boundaries.right - refRect.right,');
  FPack.Add('      height: boundaries.height');
  FPack.Add('    },');
  FPack.Add('    bottom: {');
  FPack.Add('      width: boundaries.width,');
  FPack.Add('      height: boundaries.bottom - refRect.bottom');
  FPack.Add('    },');
  FPack.Add('    left: {');
  FPack.Add('      width: refRect.left - boundaries.left,');
  FPack.Add('      height: boundaries.height');
  FPack.Add('    }');
  FPack.Add('  };');
  FPack.Add('');
  FPack.Add('  var sortedAreas = Object.keys(rects).map(function (key) {');
  FPack.Add('    return _extends({');
  FPack.Add('      key: key');
  FPack.Add('    }, rects[key], {');
  FPack.Add('      area: getArea(rects[key])');
  FPack.Add('    });');
  FPack.Add('  }).sort(function (a, b) {');
  FPack.Add('    return b.area - a.area;');
  FPack.Add('  });');
  FPack.Add('');
  FPack.Add('  var filteredAreas = sortedAreas.filter(function (_ref2) {');
  FPack.Add('    var width = _ref2.width,');
  FPack.Add('        height = _ref2.height;');
  FPack.Add('    return width >= popper.clientWidth && height >= popper.clientHeight;');
  FPack.Add('  });');
  FPack.Add('');
  FPack.Add('  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : ');
  FPack.Add('sortedAreas[0].key;');
  FPack.Add('');
  FPack.Add('  var variation = placement.split(''-'')[1];');
  FPack.Add('');
  FPack.Add('  return computedPlacement + (variation ? ''-'' + variation : '''');');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * Get offsets to the reference element');
  FPack.Add(' * @method');
  FPack.Add(' * @memberof Popper.Utils');
  FPack.Add(' * @param {Object} state');
  FPack.Add(' * @param {Element} popper - the popper element');
  FPack.Add(' * @param {Element} reference - the reference element (the popper will be ');
  FPack.Add('relative to this)');
  FPack.Add(' * @returns {Object} An object containing the offsets which will be applied to ');
  FPack.Add('the popper');
  FPack.Add(' */');
  FPack.Add('function getReferenceOffsets(state, popper, reference) {');
  FPack.Add('  var commonOffsetParent = findCommonOffsetParent(popper, reference);');
  FPack.Add('  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent);');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * Get the outer sizes of the given element (offset size + margins)');
  FPack.Add(' * @method');
  FPack.Add(' * @memberof Popper.Utils');
  FPack.Add(' * @argument {Element} element');
  FPack.Add(' * @returns {Object} object containing width and height properties');
  FPack.Add(' */');
  FPack.Add('function getOuterSizes(element) {');
  FPack.Add('  var styles = getComputedStyle(element);');
  FPack.Add('  var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);');
  FPack.Add('  var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);');
  FPack.Add('  var result = {');
  FPack.Add('    width: element.offsetWidth + y,');
  FPack.Add('    height: element.offsetHeight + x');
  FPack.Add('  };');
  FPack.Add('  return result;');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * Get the opposite placement of the given one');
  FPack.Add(' * @method');
  FPack.Add(' * @memberof Popper.Utils');
  FPack.Add(' * @argument {String} placement');
  FPack.Add(' * @returns {String} flipped placement');
  FPack.Add(' */');
  FPack.Add('function getOppositePlacement(placement) {');
  FPack.Add('  var hash = { left: ''right'', right: ''left'', bottom: ''top'', top: ''bottom'' };');
  FPack.Add('  return placement.replace(/left|right|bottom|top/g, function (matched) {');
  FPack.Add('    return hash[matched];');
  FPack.Add('  });');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * Get offsets to the popper');
  FPack.Add(' * @method');
  FPack.Add(' * @memberof Popper.Utils');
  FPack.Add(' * @param {Object} position - CSS position the Popper will get applied');
  FPack.Add(' * @param {HTMLElement} popper - the popper element');
  FPack.Add(' * @param {Object} referenceOffsets - the reference offsets (the popper will be ');
  FPack.Add('relative to this)');
  FPack.Add(' * @param {String} placement - one of the valid placement options');
  FPack.Add(' * @returns {Object} popperOffsets - An object containing the offsets which ');
  FPack.Add('will be applied to the popper');
  FPack.Add(' */');
  FPack.Add('function getPopperOffsets(popper, referenceOffsets, placement) {');
  FPack.Add('  placement = placement.split(''-'')[0];');
  FPack.Add('');
  FPack.Add('  // Get popper node sizes');
  FPack.Add('  var popperRect = getOuterSizes(popper);');
  FPack.Add('');
  FPack.Add('  // Add position, width and height to our offsets object');
  FPack.Add('  var popperOffsets = {');
  FPack.Add('    width: popperRect.width,');
  FPack.Add('    height: popperRect.height');
  FPack.Add('  };');
  FPack.Add('');
  FPack.Add('  // depending by the popper placement we have to compute its offsets slightly ');
  FPack.Add('differently');
  FPack.Add('  var isHoriz = [''right'', ''left''].indexOf(placement) !== -1;');
  FPack.Add('  var mainSide = isHoriz ? ''top'' : ''left'';');
  FPack.Add('  var secondarySide = isHoriz ? ''left'' : ''top'';');
  FPack.Add('  var measurement = isHoriz ? ''height'' : ''width'';');
  FPack.Add('  var secondaryMeasurement = !isHoriz ? ''height'' : ''width'';');
  FPack.Add('');
  FPack.Add('  popperOffsets[mainSide] = referenceOffsets[mainSide] + ');
  FPack.Add('referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;');
  FPack.Add('  if (placement === secondarySide) {');
  FPack.Add('    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - ');
  FPack.Add('popperRect[secondaryMeasurement];');
  FPack.Add('  } else {');
  FPack.Add('    popperOffsets[secondarySide] = ');
  FPack.Add('referenceOffsets[getOppositePlacement(secondarySide)];');
  FPack.Add('  }');
  FPack.Add('');
  FPack.Add('  return popperOffsets;');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * Mimics the `find` method of Array');
  FPack.Add(' * @method');
  FPack.Add(' * @memberof Popper.Utils');
  FPack.Add(' * @argument {Array} arr');
  FPack.Add(' * @argument prop');
  FPack.Add(' * @argument value');
  FPack.Add(' * @returns index or -1');
  FPack.Add(' */');
  FPack.Add('function find(arr, check) {');
  FPack.Add('  // use native find if supported');
  FPack.Add('  if (Array.prototype.find) {');
  FPack.Add('    return arr.find(check);');
  FPack.Add('  }');
  FPack.Add('');
  FPack.Add('  // use `filter` to obtain the same behavior of `find`');
  FPack.Add('  return arr.filter(check)[0];');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * Return the index of the matching object');
  FPack.Add(' * @method');
  FPack.Add(' * @memberof Popper.Utils');
  FPack.Add(' * @argument {Array} arr');
  FPack.Add(' * @argument prop');
  FPack.Add(' * @argument value');
  FPack.Add(' * @returns index or -1');
  FPack.Add(' */');
  FPack.Add('function findIndex(arr, prop, value) {');
  FPack.Add('  // use native findIndex if supported');
  FPack.Add('  if (Array.prototype.findIndex) {');
  FPack.Add('    return arr.findIndex(function (cur) {');
  FPack.Add('      return cur[prop] === value;');
  FPack.Add('    });');
  FPack.Add('  }');
  FPack.Add('');
  FPack.Add('  // use `find` + `indexOf` if `findIndex` isn''t supported');
  FPack.Add('  var match = find(arr, function (obj) {');
  FPack.Add('    return obj[prop] === value;');
  FPack.Add('  });');
  FPack.Add('  return arr.indexOf(match);');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * Loop trough the list of modifiers and run them in order,');
  FPack.Add(' * each of them will then edit the data object.');
  FPack.Add(' * @method');
  FPack.Add(' * @memberof Popper.Utils');
  FPack.Add(' * @param {dataObject} data');
  FPack.Add(' * @param {Array} modifiers');
  FPack.Add(' * @param {String} ends - Optional modifier name used as stopper');
  FPack.Add(' * @returns {dataObject}');
  FPack.Add(' */');
  FPack.Add('function runModifiers(modifiers, data, ends) {');
  FPack.Add('  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, ');
  FPack.Add('findIndex(modifiers, ''name'', ends));');
  FPack.Add('');
  FPack.Add('  modifiersToRun.forEach(function (modifier) {');
  FPack.Add('    if (modifier[''function'']) {');
  FPack.Add('      // eslint-disable-line dot-notation');
  FPack.Add('      console.warn(''`modifier.function` is deprecated, use `modifier.fn`!'');');
  FPack.Add('    }');
  FPack.Add('    var fn = modifier[''function''] || modifier.fn; // eslint-disable-line dot-');
  FPack.Add('notation');
  FPack.Add('    if (modifier.enabled && isFunction(fn)) {');
  FPack.Add('      // Add properties to offsets to make them a complete clientRect object');
  FPack.Add('      // we do this before each modifier to make sure the previous one doesn''t');
  FPack.Add('      // mess with these values');
  FPack.Add('      data.offsets.popper = getClientRect(data.offsets.popper);');
  FPack.Add('      data.offsets.reference = getClientRect(data.offsets.reference);');
  FPack.Add('');
  FPack.Add('      data = fn(data, modifier);');
  FPack.Add('    }');
  FPack.Add('  });');
  FPack.Add('');
  FPack.Add('  return data;');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * Updates the position of the popper, computing the new offsets and applying');
  FPack.Add(' * the new style.<br />');
  FPack.Add(' * Prefer `scheduleUpdate` over `update` because of performance reasons.');
  FPack.Add(' * @method');
  FPack.Add(' * @memberof Popper');
  FPack.Add(' */');
  FPack.Add('function update() {');
  FPack.Add('  // if popper is destroyed, don''t perform any further update');
  FPack.Add('  if (this.state.isDestroyed) {');
  FPack.Add('    return;');
  FPack.Add('  }');
  FPack.Add('');
  FPack.Add('  var data = {');
  FPack.Add('    instance: this,');
  FPack.Add('    styles: {},');
  FPack.Add('    arrowStyles: {},');
  FPack.Add('    attributes: {},');
  FPack.Add('    flipped: false,');
  FPack.Add('    offsets: {}');
  FPack.Add('  };');
  FPack.Add('');
  FPack.Add('  // compute reference element offsets');
  FPack.Add('  data.offsets.reference = getReferenceOffsets(this.state, this.popper, ');
  FPack.Add('this.reference);');
  FPack.Add('');
  FPack.Add('  // compute auto placement, store placement inside the data object,');
  FPack.Add('  // modifiers will be able to edit `placement` if needed');
  FPack.Add('  // and refer to originalPlacement to know the original value');
  FPack.Add('  data.placement = computeAutoPlacement(this.options.placement, ');
  FPack.Add('data.offsets.reference, this.popper, this.reference, ');
  FPack.Add('this.options.modifiers.flip.boundariesElement, ');
  FPack.Add('this.options.modifiers.flip.padding);');
  FPack.Add('');
  FPack.Add('  // store the computed placement inside `originalPlacement`');
  FPack.Add('  data.originalPlacement = data.placement;');
  FPack.Add('');
  FPack.Add('  // compute the popper offsets');
  FPack.Add('  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, ');
  FPack.Add('data.placement);');
  FPack.Add('  data.offsets.popper.position = ''absolute'';');
  FPack.Add('');
  FPack.Add('  // run the modifiers');
  FPack.Add('  data = runModifiers(this.modifiers, data);');
  FPack.Add('');
  FPack.Add('  // the first `update` will call `onCreate` callback');
  FPack.Add('  // the other ones will call `onUpdate` callback');
  FPack.Add('  if (!this.state.isCreated) {');
  FPack.Add('    this.state.isCreated = true;');
  FPack.Add('    this.options.onCreate(data);');
  FPack.Add('  } else {');
  FPack.Add('    this.options.onUpdate(data);');
  FPack.Add('  }');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * Helper used to know if the given modifier is enabled.');
  FPack.Add(' * @method');
  FPack.Add(' * @memberof Popper.Utils');
  FPack.Add(' * @returns {Boolean}');
  FPack.Add(' */');
  FPack.Add('function isModifierEnabled(modifiers, modifierName) {');
  FPack.Add('  return modifiers.some(function (_ref) {');
  FPack.Add('    var name = _ref.name,');
  FPack.Add('        enabled = _ref.enabled;');
  FPack.Add('    return enabled && name === modifierName;');
  FPack.Add('  });');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * Get the prefixed supported property name');
end; 

procedure TPopperJS.PopperJS_4;
begin
  FPack.Add(' * @method');
  FPack.Add(' * @memberof Popper.Utils');
  FPack.Add(' * @argument {String} property (camelCase)');
  FPack.Add(' * @returns {String} prefixed property (camelCase or PascalCase, depending on ');
  FPack.Add('the vendor prefix)');
  FPack.Add(' */');
  FPack.Add('function getSupportedPropertyName(property) {');
  FPack.Add('  var prefixes = [false, ''ms'', ''Webkit'', ''Moz'', ''O''];');
  FPack.Add('  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);');
  FPack.Add('');
  FPack.Add('  for (var i = 0; i < prefixes.length - 1; i++) {');
  FPack.Add('    var prefix = prefixes[i];');
  FPack.Add('    var toCheck = prefix ? '''' + prefix + upperProp : property;');
  FPack.Add('    if (typeof document.body.style[toCheck] !== ''undefined'') {');
  FPack.Add('      return toCheck;');
  FPack.Add('    }');
  FPack.Add('  }');
  FPack.Add('  return null;');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * Destroy the popper');
  FPack.Add(' * @method');
  FPack.Add(' * @memberof Popper');
  FPack.Add(' */');
  FPack.Add('function destroy() {');
  FPack.Add('  this.state.isDestroyed = true;');
  FPack.Add('');
  FPack.Add('  // touch DOM only if `applyStyle` modifier is enabled');
  FPack.Add('  if (isModifierEnabled(this.modifiers, ''applyStyle'')) {');
  FPack.Add('    this.popper.removeAttribute(''x-placement'');');
  FPack.Add('    this.popper.style.left = '''';');
  FPack.Add('    this.popper.style.position = '''';');
  FPack.Add('    this.popper.style.top = '''';');
  FPack.Add('    this.popper.style[getSupportedPropertyName(''transform'')] = '''';');
  FPack.Add('  }');
  FPack.Add('');
  FPack.Add('  this.disableEventListeners();');
  FPack.Add('');
  FPack.Add('  // remove the popper if user explicity asked for the deletion on destroy');
  FPack.Add('  // do not use `remove` because IE11 doesn''t support it');
  FPack.Add('  if (this.options.removeOnDestroy) {');
  FPack.Add('    this.popper.parentNode.removeChild(this.popper);');
  FPack.Add('  }');
  FPack.Add('  return this;');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * Get the window associated with the element');
  FPack.Add(' * @argument {Element} element');
  FPack.Add(' * @returns {Window}');
  FPack.Add(' */');
  FPack.Add('function getWindow(element) {');
  FPack.Add('  var ownerDocument = element.ownerDocument;');
  FPack.Add('  return ownerDocument ? ownerDocument.defaultView : window;');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('function attachToScrollParents(scrollParent, event, callback, scrollParents) {');
  FPack.Add('  var isBody = scrollParent.nodeName === ''BODY'';');
  FPack.Add('  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;');
  FPack.Add('  target.addEventListener(event, callback, { passive: true });');
  FPack.Add('');
  FPack.Add('  if (!isBody) {');
  FPack.Add('    attachToScrollParents(getScrollParent(target.parentNode), event, callback, ');
  FPack.Add('scrollParents);');
  FPack.Add('  }');
  FPack.Add('  scrollParents.push(target);');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * Setup needed event listeners used to update the popper position');
  FPack.Add(' * @method');
  FPack.Add(' * @memberof Popper.Utils');
  FPack.Add(' * @private');
  FPack.Add(' */');
  FPack.Add('function setupEventListeners(reference, options, state, updateBound) {');
  FPack.Add('  // Resize event listener on window');
  FPack.Add('  state.updateBound = updateBound;');
  FPack.Add('  getWindow(reference).addEventListener(''resize'', state.updateBound, { passive: ');
  FPack.Add('true });');
  FPack.Add('');
  FPack.Add('  // Scroll event listener on scroll parents');
  FPack.Add('  var scrollElement = getScrollParent(reference);');
  FPack.Add('  attachToScrollParents(scrollElement, ''scroll'', state.updateBound, ');
  FPack.Add('state.scrollParents);');
  FPack.Add('  state.scrollElement = scrollElement;');
  FPack.Add('  state.eventsEnabled = true;');
  FPack.Add('');
  FPack.Add('  return state;');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * It will add resize/scroll events and start recalculating');
  FPack.Add(' * position of the popper element when they are triggered.');
  FPack.Add(' * @method');
  FPack.Add(' * @memberof Popper');
  FPack.Add(' */');
  FPack.Add('function enableEventListeners() {');
  FPack.Add('  if (!this.state.eventsEnabled) {');
  FPack.Add('    this.state = setupEventListeners(this.reference, this.options, this.state, ');
  FPack.Add('this.scheduleUpdate);');
  FPack.Add('  }');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * Remove event listeners used to update the popper position');
  FPack.Add(' * @method');
  FPack.Add(' * @memberof Popper.Utils');
  FPack.Add(' * @private');
  FPack.Add(' */');
  FPack.Add('function removeEventListeners(reference, state) {');
  FPack.Add('  // Remove resize event listener on window');
  FPack.Add('  getWindow(reference).removeEventListener(''resize'', state.updateBound);');
  FPack.Add('');
  FPack.Add('  // Remove scroll event listener on scroll parents');
  FPack.Add('  state.scrollParents.forEach(function (target) {');
  FPack.Add('    target.removeEventListener(''scroll'', state.updateBound);');
  FPack.Add('  });');
  FPack.Add('');
  FPack.Add('  // Reset state');
  FPack.Add('  state.updateBound = null;');
  FPack.Add('  state.scrollParents = [];');
  FPack.Add('  state.scrollElement = null;');
  FPack.Add('  state.eventsEnabled = false;');
  FPack.Add('  return state;');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * It will remove resize/scroll events and won''t recalculate popper position');
  FPack.Add(' * when they are triggered. It also won''t trigger onUpdate callback anymore,');
  FPack.Add(' * unless you call `update` method manually.');
  FPack.Add(' * @method');
  FPack.Add(' * @memberof Popper');
  FPack.Add(' */');
  FPack.Add('function disableEventListeners() {');
  FPack.Add('  if (this.state.eventsEnabled) {');
  FPack.Add('    cancelAnimationFrame(this.scheduleUpdate);');
  FPack.Add('    this.state = removeEventListeners(this.reference, this.state);');
  FPack.Add('  }');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * Tells if a given input is a number');
  FPack.Add(' * @method');
  FPack.Add(' * @memberof Popper.Utils');
  FPack.Add(' * @param {*} input to check');
  FPack.Add(' * @return {Boolean}');
  FPack.Add(' */');
  FPack.Add('function isNumeric(n) {');
  FPack.Add('  return n !== '''' && !isNaN(parseFloat(n)) && isFinite(n);');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * Set the style to the given popper');
  FPack.Add(' * @method');
  FPack.Add(' * @memberof Popper.Utils');
  FPack.Add(' * @argument {Element} element - Element to apply the style to');
  FPack.Add(' * @argument {Object} styles');
  FPack.Add(' * Object with a list of properties and values which will be applied to the ');
  FPack.Add('element');
  FPack.Add(' */');
  FPack.Add('function setStyles(element, styles) {');
  FPack.Add('  Object.keys(styles).forEach(function (prop) {');
  FPack.Add('    var unit = '''';');
  FPack.Add('    // add unit if the value is numeric and is one of the following');
  FPack.Add('    if ([''width'', ''height'', ''top'', ''right'', ''bottom'', ''left''].indexOf(prop) !== ');
  FPack.Add('-1 && isNumeric(styles[prop])) {');
  FPack.Add('      unit = ''px'';');
  FPack.Add('    }');
  FPack.Add('    element.style[prop] = styles[prop] + unit;');
  FPack.Add('  });');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * Set the attributes to the given popper');
  FPack.Add(' * @method');
  FPack.Add(' * @memberof Popper.Utils');
  FPack.Add(' * @argument {Element} element - Element to apply the attributes to');
  FPack.Add(' * @argument {Object} styles');
  FPack.Add(' * Object with a list of properties and values which will be applied to the ');
  FPack.Add('element');
  FPack.Add(' */');
  FPack.Add('function setAttributes(element, attributes) {');
  FPack.Add('  Object.keys(attributes).forEach(function (prop) {');
  FPack.Add('    var value = attributes[prop];');
  FPack.Add('    if (value !== false) {');
  FPack.Add('      element.setAttribute(prop, attributes[prop]);');
  FPack.Add('    } else {');
  FPack.Add('      element.removeAttribute(prop);');
  FPack.Add('    }');
  FPack.Add('  });');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * @function');
  FPack.Add(' * @memberof Modifiers');
  FPack.Add(' * @argument {Object} data - The data object generated by `update` method');
  FPack.Add(' * @argument {Object} data.styles - List of style properties - values to apply ');
  FPack.Add('to popper element');
  FPack.Add(' * @argument {Object} data.attributes - List of attribute properties - values ');
  FPack.Add('to apply to popper element');
  FPack.Add(' * @argument {Object} options - Modifiers configuration and options');
  FPack.Add(' * @returns {Object} The same data object');
  FPack.Add(' */');
  FPack.Add('function applyStyle(data) {');
  FPack.Add('  // any property present in `data.styles` will be applied to the popper,');
  FPack.Add('  // in this way we can make the 3rd party modifiers add custom styles to it');
  FPack.Add('  // Be aware, modifiers could override the properties defined in the previous');
  FPack.Add('  // lines of this modifier!');
  FPack.Add('  setStyles(data.instance.popper, data.styles);');
  FPack.Add('');
  FPack.Add('  // any property present in `data.attributes` will be applied to the popper,');
  FPack.Add('  // they will be set as HTML attributes of the element');
  FPack.Add('  setAttributes(data.instance.popper, data.attributes);');
  FPack.Add('');
  FPack.Add('  // if arrowElement is defined and arrowStyles has some properties');
  FPack.Add('  if (data.arrowElement && Object.keys(data.arrowStyles).length) {');
  FPack.Add('    setStyles(data.arrowElement, data.arrowStyles);');
  FPack.Add('  }');
  FPack.Add('');
  FPack.Add('  return data;');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * Set the x-placement attribute before everything else because it could be used');
  FPack.Add(' * to add margins to the popper margins needs to be calculated to get the');
  FPack.Add(' * correct popper offsets.');
  FPack.Add(' * @method');
  FPack.Add(' * @memberof Popper.modifiers');
  FPack.Add(' * @param {HTMLElement} reference - The reference element used to position the ');
  FPack.Add('popper');
  FPack.Add(' * @param {HTMLElement} popper - The HTML element used as popper.');
  FPack.Add(' * @param {Object} options - Popper.js options');
  FPack.Add(' */');
  FPack.Add('function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {');
  FPack.Add('  // compute reference element offsets');
  FPack.Add('  var referenceOffsets = getReferenceOffsets(state, popper, reference);');
  FPack.Add('');
  FPack.Add('  // compute auto placement, store placement inside the data object,');
  FPack.Add('  // modifiers will be able to edit `placement` if needed');
  FPack.Add('  // and refer to originalPlacement to know the original value');
  FPack.Add('  var placement = computeAutoPlacement(options.placement, referenceOffsets, ');
  FPack.Add('popper, reference, options.modifiers.flip.boundariesElement, ');
  FPack.Add('options.modifiers.flip.padding);');
  FPack.Add('');
  FPack.Add('  popper.setAttribute(''x-placement'', placement);');
  FPack.Add('');
  FPack.Add('  // Apply `position` to popper before anything else because');
  FPack.Add('  // without the position applied we can''t guarantee correct computations');
  FPack.Add('  setStyles(popper, { position: ''absolute'' });');
  FPack.Add('');
  FPack.Add('  return options;');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * @function');
  FPack.Add(' * @memberof Modifiers');
  FPack.Add(' * @argument {Object} data - The data object generated by `update` method');
  FPack.Add(' * @argument {Object} options - Modifiers configuration and options');
  FPack.Add(' * @returns {Object} The data object, properly modified');
  FPack.Add(' */');
  FPack.Add('function computeStyle(data, options) {');
  FPack.Add('  var x = options.x,');
  FPack.Add('      y = options.y;');
  FPack.Add('  var popper = data.offsets.popper;');
  FPack.Add('');
  FPack.Add('  // Remove this legacy support in Popper.js v2');
  FPack.Add('');
  FPack.Add('  var legacyGpuAccelerationOption = find(data.instance.modifiers, function ');
  FPack.Add('(modifier) {');
  FPack.Add('    return modifier.name === ''applyStyle'';');
  FPack.Add('  }).gpuAcceleration;');
  FPack.Add('  if (legacyGpuAccelerationOption !== undefined) {');
  FPack.Add('    ');
  FPack.Add('console.warn(''WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!'');');
  FPack.Add('  }');
  FPack.Add('  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? ');
  FPack.Add('legacyGpuAccelerationOption : options.gpuAcceleration;');
  FPack.Add('');
  FPack.Add('  var offsetParent = getOffsetParent(data.instance.popper);');
  FPack.Add('  var offsetParentRect = getBoundingClientRect(offsetParent);');
  FPack.Add('');
  FPack.Add('  // Styles');
  FPack.Add('  var styles = {');
  FPack.Add('    position: popper.position');
  FPack.Add('  };');
  FPack.Add('');
  FPack.Add('  // floor sides to avoid blurry text');
  FPack.Add('  var offsets = {');
  FPack.Add('    left: Math.floor(popper.left),');
  FPack.Add('    top: Math.floor(popper.top),');
  FPack.Add('    bottom: Math.floor(popper.bottom),');
  FPack.Add('    right: Math.floor(popper.right)');
  FPack.Add('  };');
  FPack.Add('');
  FPack.Add('  var sideA = x === ''bottom'' ? ''top'' : ''bottom'';');
  FPack.Add('  var sideB = y === ''right'' ? ''left'' : ''right'';');
  FPack.Add('');
  FPack.Add('  // if gpuAcceleration is set to `true` and transform is supported,');
  FPack.Add('  //  we use `translate3d` to apply the position to the popper we');
  FPack.Add('  // automatically use the supported prefixed version if needed');
  FPack.Add('  var prefixedProperty = getSupportedPropertyName(''transform'');');
  FPack.Add('');
  FPack.Add('  // now, let''s make a step back and look at this code closely (wtf?)');
  FPack.Add('  // If the content of the popper grows once it''s been positioned, it');
  FPack.Add('  // may happen that the popper gets misplaced because of the new content');
  FPack.Add('  // overflowing its reference element');
  FPack.Add('  // To avoid this problem, we provide two options (x and y), which allow');
  FPack.Add('  // the consumer to define the offset origin.');
  FPack.Add('  // If we position a popper on top of a reference element, we can set');
  FPack.Add('  // `x` to `top` to make the popper grow towards its top instead of');
  FPack.Add('  // its bottom.');
  FPack.Add('  var left = void 0,');
  FPack.Add('      top = void 0;');
  FPack.Add('  if (sideA === ''bottom'') {');
  FPack.Add('    top = -offsetParentRect.height + offsets.bottom;');
  FPack.Add('  } else {');
  FPack.Add('    top = offsets.top;');
  FPack.Add('  }');
  FPack.Add('  if (sideB === ''right'') {');
  FPack.Add('    left = -offsetParentRect.width + offsets.right;');
  FPack.Add('  } else {');
  FPack.Add('    left = offsets.left;');
  FPack.Add('  }');
  FPack.Add('  if (gpuAcceleration && prefixedProperty) {');
  FPack.Add('    styles[prefixedProperty] = ''translate3d('' + left + ''px, '' + top + ''px, 0)'';');
  FPack.Add('    styles[sideA] = 0;');
  FPack.Add('    styles[sideB] = 0;');
  FPack.Add('    styles.willChange = ''transform'';');
  FPack.Add('  } else {');
  FPack.Add('    // othwerise, we use the standard `top`, `left`, `bottom` and `right` ');
  FPack.Add('properties');
  FPack.Add('    var invertTop = sideA === ''bottom'' ? -1 : 1;');
  FPack.Add('    var invertLeft = sideB === ''right'' ? -1 : 1;');
  FPack.Add('    styles[sideA] = top * invertTop;');
  FPack.Add('    styles[sideB] = left * invertLeft;');
end;


procedure TPopperJS.PopperJS_5;
begin
  FPack.Add('    styles.willChange = sideA + '', '' + sideB;');
  FPack.Add('  }');
  FPack.Add('');
  FPack.Add('  // Attributes');
  FPack.Add('  var attributes = {');
  FPack.Add('    ''x-placement'': data.placement');
  FPack.Add('  };');
  FPack.Add('');
  FPack.Add('  // Update `data` attributes, styles and arrowStyles');
  FPack.Add('  data.attributes = _extends({}, attributes, data.attributes);');
  FPack.Add('  data.styles = _extends({}, styles, data.styles);');
  FPack.Add('  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);');
  FPack.Add('');
  FPack.Add('  return data;');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * Helper used to know if the given modifier depends from another one.<br />');
  FPack.Add(' * It checks if the needed modifier is listed and enabled.');
  FPack.Add(' * @method');
  FPack.Add(' * @memberof Popper.Utils');
  FPack.Add(' * @param {Array} modifiers - list of modifiers');
  FPack.Add(' * @param {String} requestingName - name of requesting modifier');
  FPack.Add(' * @param {String} requestedName - name of requested modifier');
  FPack.Add(' * @returns {Boolean}');
  FPack.Add(' */');
  FPack.Add('function isModifierRequired(modifiers, requestingName, requestedName) {');
  FPack.Add('  var requesting = find(modifiers, function (_ref) {');
  FPack.Add('    var name = _ref.name;');
  FPack.Add('    return name === requestingName;');
  FPack.Add('  });');
  FPack.Add('');
  FPack.Add('  var isRequired = !!requesting && modifiers.some(function (modifier) {');
  FPack.Add('    return modifier.name === requestedName && modifier.enabled && ');
  FPack.Add('modifier.order < requesting.order;');
  FPack.Add('  });');
  FPack.Add('');
  FPack.Add('  if (!isRequired) {');
  FPack.Add('    var _requesting = ''`'' + requestingName + ''`'';');
  FPack.Add('    var requested = ''`'' + requestedName + ''`'';');
  FPack.Add('    console.warn(requested + '' modifier is required by '' + _requesting + ');
  FPack.Add(''' modifier in order to work, be sure to include it before '' + _requesting + ');
  FPack.Add('''!'');');
  FPack.Add('  }');
  FPack.Add('  return isRequired;');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * @function');
  FPack.Add(' * @memberof Modifiers');
  FPack.Add(' * @argument {Object} data - The data object generated by update method');
  FPack.Add(' * @argument {Object} options - Modifiers configuration and options');
  FPack.Add(' * @returns {Object} The data object, properly modified');
  FPack.Add(' */');
  FPack.Add('function arrow(data, options) {');
  FPack.Add('  var _data$offsets$arrow;');
  FPack.Add('');
  FPack.Add('  // arrow depends on keepTogether in order to work');
  FPack.Add('  if (!isModifierRequired(data.instance.modifiers, ''arrow'', ''keepTogether'')) {');
  FPack.Add('    return data;');
  FPack.Add('  }');
  FPack.Add('');
  FPack.Add('  var arrowElement = options.element;');
  FPack.Add('');
  FPack.Add('  // if arrowElement is a string, suppose it''s a CSS selector');
  FPack.Add('  if (typeof arrowElement === ''string'') {');
  FPack.Add('    arrowElement = data.instance.popper.querySelector(arrowElement);');
  FPack.Add('');
  FPack.Add('    // if arrowElement is not found, don''t run the modifier');
  FPack.Add('    if (!arrowElement) {');
  FPack.Add('      return data;');
  FPack.Add('    }');
  FPack.Add('  } else {');
  FPack.Add('    // if the arrowElement isn''t a query selector we must check that the');
  FPack.Add('    // provided DOM node is child of its popper node');
  FPack.Add('    if (!data.instance.popper.contains(arrowElement)) {');
  FPack.Add('      ');
  FPack.Add('console.warn(''WARNING: `arrow.element` must be child of its popper element!'');');
  FPack.Add('      return data;');
  FPack.Add('    }');
  FPack.Add('  }');
  FPack.Add('');
  FPack.Add('  var placement = data.placement.split(''-'')[0];');
  FPack.Add('  var _data$offsets = data.offsets,');
  FPack.Add('      popper = _data$offsets.popper,');
  FPack.Add('      reference = _data$offsets.reference;');
  FPack.Add('');
  FPack.Add('  var isVertical = [''left'', ''right''].indexOf(placement) !== -1;');
  FPack.Add('');
  FPack.Add('  var len = isVertical ? ''height'' : ''width'';');
  FPack.Add('  var sideCapitalized = isVertical ? ''Top'' : ''Left'';');
  FPack.Add('  var side = sideCapitalized.toLowerCase();');
  FPack.Add('  var altSide = isVertical ? ''left'' : ''top'';');
  FPack.Add('  var opSide = isVertical ? ''bottom'' : ''right'';');
  FPack.Add('  var arrowElementSize = getOuterSizes(arrowElement)[len];');
  FPack.Add('');
  FPack.Add('  //');
  FPack.Add('  // extends keepTogether behavior making sure the popper and its');
  FPack.Add('  // reference have enough pixels in conjuction');
  FPack.Add('  //');
  FPack.Add('');
  FPack.Add('  // top/left side');
  FPack.Add('  if (reference[opSide] - arrowElementSize < popper[side]) {');
  FPack.Add('    data.offsets.popper[side] -= popper[side] - (reference[opSide] - ');
  FPack.Add('arrowElementSize);');
  FPack.Add('  }');
  FPack.Add('  // bottom/right side');
  FPack.Add('  if (reference[side] + arrowElementSize > popper[opSide]) {');
  FPack.Add('    data.offsets.popper[side] += reference[side] + arrowElementSize - ');
  FPack.Add('popper[opSide];');
  FPack.Add('  }');
  FPack.Add('  data.offsets.popper = getClientRect(data.offsets.popper);');
  FPack.Add('');
  FPack.Add('  // compute center of the popper');
  FPack.Add('  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;');
  FPack.Add('');
  FPack.Add('  // Compute the sideValue using the updated popper offsets');
  FPack.Add('  // take popper margin in account because we don''t have this info available');
  FPack.Add('  var css = getStyleComputedProperty(data.instance.popper);');
  FPack.Add('  var popperMarginSide = parseFloat(css[''margin'' + sideCapitalized], 10);');
  FPack.Add('  var popperBorderSide = parseFloat(css[''border'' + sideCapitalized + ''Width''], ');
  FPack.Add('10);');
  FPack.Add('  var sideValue = center - data.offsets.popper[side] - popperMarginSide - ');
  FPack.Add('popperBorderSide;');
  FPack.Add('');
  FPack.Add('  // prevent arrowElement from being placed not contiguously to its popper');
  FPack.Add('  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);');
  FPack.Add('');
  FPack.Add('  data.arrowElement = arrowElement;');
  FPack.Add('  data.offsets.arrow = (_data$offsets$arrow = {}, ');
  FPack.Add('defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), ');
  FPack.Add('defineProperty(_data$offsets$arrow, altSide, ''''), _data$offsets$arrow);');
  FPack.Add('');
  FPack.Add('  return data;');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * Get the opposite placement variation of the given one');
  FPack.Add(' * @method');
  FPack.Add(' * @memberof Popper.Utils');
  FPack.Add(' * @argument {String} placement variation');
  FPack.Add(' * @returns {String} flipped placement variation');
  FPack.Add(' */');
  FPack.Add('function getOppositeVariation(variation) {');
  FPack.Add('  if (variation === ''end'') {');
  FPack.Add('    return ''start'';');
  FPack.Add('  } else if (variation === ''start'') {');
  FPack.Add('    return ''end'';');
  FPack.Add('  }');
  FPack.Add('  return variation;');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * List of accepted placements to use as values of the `placement` option.<br />');
  FPack.Add(' * Valid placements are:');
  FPack.Add(' * - `auto`');
  FPack.Add(' * - `top`');
  FPack.Add(' * - `right`');
  FPack.Add(' * - `bottom`');
  FPack.Add(' * - `left`');
  FPack.Add(' *');
  FPack.Add(' * Each placement can have a variation from this list:');
  FPack.Add(' * - `-start`');
  FPack.Add(' * - `-end`');
  FPack.Add(' *');
  FPack.Add(' * Variations are interpreted easily if you think of them as the left to right');
  FPack.Add(' * written languages. Horizontally (`top` and `bottom`), `start` is left and ');
  FPack.Add('`end`');
  FPack.Add(' * is right.<br />');
  FPack.Add(' * Vertically (`left` and `right`), `start` is top and `end` is bottom.');
  FPack.Add(' *');
  FPack.Add(' * Some valid examples are:');
  FPack.Add(' * - `top-end` (on top of reference, right aligned)');
  FPack.Add(' * - `right-start` (on right of reference, top aligned)');
  FPack.Add(' * - `bottom` (on bottom, centered)');
  FPack.Add(' * - `auto-right` (on the side with more space available, alignment depends by ');
  FPack.Add('placement)');
  FPack.Add(' *');
  FPack.Add(' * @static');
  FPack.Add(' * @type {Array}');
  FPack.Add(' * @enum {String}');
  FPack.Add(' * @readonly');
  FPack.Add(' * @method placements');
  FPack.Add(' * @memberof Popper');
  FPack.Add(' */');
  FPack.Add('var placements = [''auto-start'', ''auto'', ''auto-end'', ''top-start'', ''top'', ');
  FPack.Add('''top-end'', ''right-start'', ''right'', ''right-end'', ''bottom-end'', ''bottom'', ');
  FPack.Add('''bottom-start'', ''left-end'', ''left'', ''left-start''];');
  FPack.Add('');
  FPack.Add('// Get rid of `auto` `auto-start` and `auto-end`');
  FPack.Add('var validPlacements = placements.slice(3);');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * Given an initial placement, returns all the subsequent placements');
  FPack.Add(' * clockwise (or counter-clockwise).');
  FPack.Add(' *');
  FPack.Add(' * @method');
  FPack.Add(' * @memberof Popper.Utils');
  FPack.Add(' * @argument {String} placement - A valid placement (it accepts variations)');
  FPack.Add(' * @argument {Boolean} counter - Set to true to walk the placements ');
  FPack.Add('counterclockwise');
  FPack.Add(' * @returns {Array} placements including their variations');
  FPack.Add(' */');
  FPack.Add('function clockwise(placement) {');
  FPack.Add('  var counter = arguments.length > 1 && arguments[1] !== undefined ? ');
  FPack.Add('arguments[1] : false;');
  FPack.Add('');
  FPack.Add('  var index = validPlacements.indexOf(placement);');
  FPack.Add('  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, ');
  FPack.Add('index));');
  FPack.Add('  return counter ? arr.reverse() : arr;');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('var BEHAVIORS = {');
  FPack.Add('  FLIP: ''flip'',');
  FPack.Add('  CLOCKWISE: ''clockwise'',');
  FPack.Add('  COUNTERCLOCKWISE: ''counterclockwise''');
  FPack.Add('};');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * @function');
  FPack.Add(' * @memberof Modifiers');
  FPack.Add(' * @argument {Object} data - The data object generated by update method');
  FPack.Add(' * @argument {Object} options - Modifiers configuration and options');
  FPack.Add(' * @returns {Object} The data object, properly modified');
  FPack.Add(' */');
  FPack.Add('function flip(data, options) {');
  FPack.Add('  // if `inner` modifier is enabled, we can''t use the `flip` modifier');
  FPack.Add('  if (isModifierEnabled(data.instance.modifiers, ''inner'')) {');
  FPack.Add('    return data;');
  FPack.Add('  }');
  FPack.Add('');
  FPack.Add('  if (data.flipped && data.placement === data.originalPlacement) {');
  FPack.Add('    // seems like flip is trying to loop, probably there''s not enough space on any of the flippable sides');
  FPack.Add('    return data;');
  FPack.Add('  }');
  FPack.Add('');
  FPack.Add('  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, ');
  FPack.Add('options.padding, options.boundariesElement);');
  FPack.Add('');
  FPack.Add('  var placement = data.placement.split(''-'')[0];');
  FPack.Add('  var placementOpposite = getOppositePlacement(placement);');
  FPack.Add('  var variation = data.placement.split(''-'')[1] || '''';');
  FPack.Add('');
  FPack.Add('  var flipOrder = [];');
  FPack.Add('');
  FPack.Add('  switch (options.behavior) {');
  FPack.Add('    case BEHAVIORS.FLIP:');
  FPack.Add('      flipOrder = [placement, placementOpposite];');
  FPack.Add('      break;');
  FPack.Add('    case BEHAVIORS.CLOCKWISE:');
  FPack.Add('      flipOrder = clockwise(placement);');
  FPack.Add('      break;');
  FPack.Add('    case BEHAVIORS.COUNTERCLOCKWISE:');
  FPack.Add('      flipOrder = clockwise(placement, true);');
  FPack.Add('      break;');
  FPack.Add('    default:');
  FPack.Add('      flipOrder = options.behavior;');
  FPack.Add('  }');
  FPack.Add('');
  FPack.Add('  flipOrder.forEach(function (step, index) {');
  FPack.Add('    if (placement !== step || flipOrder.length === index + 1) {');
  FPack.Add('      return data;');
  FPack.Add('    }');
  FPack.Add('');
  FPack.Add('    placement = data.placement.split(''-'')[0];');
  FPack.Add('    placementOpposite = getOppositePlacement(placement);');
  FPack.Add('');
  FPack.Add('    var popperOffsets = data.offsets.popper;');
  FPack.Add('    var refOffsets = data.offsets.reference;');
  FPack.Add('');
  FPack.Add('    // using floor because the reference offsets may contain decimals we are '
  + 'not going to consider here');
  FPack.Add('    var floor = Math.floor;');
  FPack.Add('    var overlapsRef = placement === ''left'' && floor(popperOffsets.right) > ');
  FPack.Add('floor(refOffsets.left) || placement === ''right'' && floor(popperOffsets.left) < ');
  FPack.Add('floor(refOffsets.right) || placement === ''top'' && floor(popperOffsets.bottom) > ');
  FPack.Add('floor(refOffsets.top) || placement === ''bottom'' && floor(popperOffsets.top) < ');
  FPack.Add('floor(refOffsets.bottom);');
  FPack.Add('');
  FPack.Add('    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);');
  FPack.Add('    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);');
  FPack.Add('    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);');
  FPack.Add('    var overflowsBottom = floor(popperOffsets.bottom) > ');
  FPack.Add('floor(boundaries.bottom);');
  FPack.Add('');
  FPack.Add('    var overflowsBoundaries = placement === ''left'' && overflowsLeft || ');
  FPack.Add('placement === ''right'' && overflowsRight || placement === ''top'' && overflowsTop ');
  FPack.Add('|| placement === ''bottom'' && overflowsBottom;');
  FPack.Add('');
  FPack.Add('    // flip the variation if required');
  FPack.Add('    var isVertical = [''top'', ''bottom''].indexOf(placement) !== -1;');
  FPack.Add('    var flippedVariation = !!options.flipVariations && (isVertical && variation ');
  FPack.Add('=== ''start'' && overflowsLeft || isVertical && variation === ''end'' && ');
  FPack.Add('overflowsRight || !isVertical && variation === ''start'' && overflowsTop || ');
  FPack.Add('!isVertical && variation === ''end'' && overflowsBottom);');
  FPack.Add('');
  FPack.Add('    if (overlapsRef || overflowsBoundaries || flippedVariation) {');
  FPack.Add('      // this boolean to detect any flip loop');
  FPack.Add('      data.flipped = true;');
  FPack.Add('');
  FPack.Add('      if (overlapsRef || overflowsBoundaries) {');
  FPack.Add('        placement = flipOrder[index + 1];');
  FPack.Add('      }');
  FPack.Add('');
  FPack.Add('      if (flippedVariation) {');
  FPack.Add('        variation = getOppositeVariation(variation);');
  FPack.Add('      }');
  FPack.Add('');
  FPack.Add('      data.placement = placement + (variation ? ''-'' + variation : '''');');
  FPack.Add('');
  FPack.Add('      // this object contains `position`, we want to preserve it along with');
  FPack.Add('      // any additional property we may add in the future');
  FPack.Add('      data.offsets.popper = _extends({}, data.offsets.popper, ');
  FPack.Add('getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));');
  FPack.Add('');
  FPack.Add('      data = runModifiers(data.instance.modifiers, data, ''flip'');');
  FPack.Add('    }');
  FPack.Add('  });');
  FPack.Add('  return data;');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * @function');
  FPack.Add(' * @memberof Modifiers');
  FPack.Add(' * @argument {Object} data - The data object generated by update method');
  FPack.Add(' * @argument {Object} options - Modifiers configuration and options');
  FPack.Add(' * @returns {Object} The data object, properly modified');
  FPack.Add(' */');
  FPack.Add('function keepTogether(data) {');
  FPack.Add('  var _data$offsets = data.offsets,');
  FPack.Add('      popper = _data$offsets.popper,');
  FPack.Add('      reference = _data$offsets.reference;');
  FPack.Add('');
  FPack.Add('  var placement = data.placement.split(''-'')[0];');
  FPack.Add('  var floor = Math.floor;');
end;

procedure TPopperJS.PopperJS_6;
begin
  FPack.Add('  var isVertical = [''top'', ''bottom''].indexOf(placement) !== -1;');
  FPack.Add('  var side = isVertical ? ''right'' : ''bottom'';');
  FPack.Add('  var opSide = isVertical ? ''left'' : ''top'';');
  FPack.Add('  var measurement = isVertical ? ''width'' : ''height'';');
  FPack.Add('');
  FPack.Add('  if (popper[side] < floor(reference[opSide])) {');
  FPack.Add('    data.offsets.popper[opSide] = floor(reference[opSide]) - ');
  FPack.Add('popper[measurement];');
  FPack.Add('  }');
  FPack.Add('  if (popper[opSide] > floor(reference[side])) {');
  FPack.Add('    data.offsets.popper[opSide] = floor(reference[side]);');
  FPack.Add('  }');
  FPack.Add('');
  FPack.Add('  return data;');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * Converts a string containing value + unit into a px value number');
  FPack.Add(' * @function');
  FPack.Add(' * @memberof {modifiers~offset}');
  FPack.Add(' * @private');
  FPack.Add(' * @argument {String} str - Value + unit string');
  FPack.Add(' * @argument {String} measurement - `height` or `width`');
  FPack.Add(' * @argument {Object} popperOffsets');
  FPack.Add(' * @argument {Object} referenceOffsets');
  FPack.Add(' * @returns {Number|String}');
  FPack.Add(' * Value in pixels, or original string if no values were extracted');
  FPack.Add(' */');
  FPack.Add('function toValue(str, measurement, popperOffsets, referenceOffsets) {');
  FPack.Add('  // separate value from unit');
  FPack.Add('  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);');
  FPack.Add('  var value = +split[1];');
  FPack.Add('  var unit = split[2];');
  FPack.Add('');
  FPack.Add('  // If it''s not a number it''s an operator, I guess');
  FPack.Add('  if (!value) {');
  FPack.Add('    return str;');
  FPack.Add('  }');
  FPack.Add('');
  FPack.Add('  if (unit.indexOf(''%'') === 0) {');
  FPack.Add('    var element = void 0;');
  FPack.Add('    switch (unit) {');
  FPack.Add('      case ''%p'':');
  FPack.Add('        element = popperOffsets;');
  FPack.Add('        break;');
  FPack.Add('      case ''%'':');
  FPack.Add('      case ''%r'':');
  FPack.Add('      default:');
  FPack.Add('        element = referenceOffsets;');
  FPack.Add('    }');
  FPack.Add('');
  FPack.Add('    var rect = getClientRect(element);');
  FPack.Add('    return rect[measurement] / 100 * value;');
  FPack.Add('  } else if (unit === ''vh'' || unit === ''vw'') {');
  FPack.Add('    // if is a vh or vw, we calculate the size based on the viewport');
  FPack.Add('    var size = void 0;');
  FPack.Add('    if (unit === ''vh'') {');
  FPack.Add('      size = Math.max(document.documentElement.clientHeight, window.innerHeight ');
  FPack.Add('|| 0);');
  FPack.Add('    } else {');
  FPack.Add('      size = Math.max(document.documentElement.clientWidth, window.innerWidth ');
  FPack.Add('|| 0);');
  FPack.Add('    }');
  FPack.Add('    return size / 100 * value;');
  FPack.Add('  } else {');
  FPack.Add('    // if is an explicit pixel unit, we get rid of the unit and keep the value');
  FPack.Add('    // if is an implicit unit, it''s px, and we return just the value');
  FPack.Add('    return value;');
  FPack.Add('  }');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.');
  FPack.Add(' * @function');
  FPack.Add(' * @memberof {modifiers~offset}');
  FPack.Add(' * @private');
  FPack.Add(' * @argument {String} offset');
  FPack.Add(' * @argument {Object} popperOffsets');
  FPack.Add(' * @argument {Object} referenceOffsets');
  FPack.Add(' * @argument {String} basePlacement');
  FPack.Add(' * @returns {Array} a two cells array with x and y offsets in numbers');
  FPack.Add(' */');
  FPack.Add('function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {');
  FPack.Add('  var offsets = [0, 0];');
  FPack.Add('');
  FPack.Add('  // Use height if placement is left or right and index is 0 otherwise use width');
  FPack.Add('  // in this way the first offset will use an axis and the second one');
  FPack.Add('  // will use the other one');
  FPack.Add('  var useHeight = [''right'', ''left''].indexOf(basePlacement) !== -1;');
  FPack.Add('');
  FPack.Add('  // Split the offset string to obtain a list of values and operands');
  FPack.Add('  // The regex addresses values with the plus or minus sign in front (+10, -20, '
  + 'etc)');
  FPack.Add('  var fragments = offset.split(/(\+|\-)/).map(function (frag) {');
  FPack.Add('    return frag.trim();');
  FPack.Add('  });');
  FPack.Add('');
  FPack.Add('  // Detect if the offset string contains a pair of values or a single one');
  FPack.Add('  // they could be separated by comma or space');
  FPack.Add('  var divider = fragments.indexOf(find(fragments, function (frag) {');
  FPack.Add('    return frag.search(/,|\s/) !== -1;');
  FPack.Add('  }));');
  FPack.Add('');
  FPack.Add('  if (fragments[divider] && fragments[divider].indexOf('','') === -1) {');
  FPack.Add('    ');
  FPack.Add('console.warn(''Offsets separated by white space(s) are deprecated, use a comma (,) instead.'');');
  FPack.Add('  }');
  FPack.Add('');
  FPack.Add('  // If divider is found, we divide the list of values and operands to divide');
  FPack.Add('  // them by ofset X and Y.');
  FPack.Add('  var splitRegex = /\s*,\s*|\s+/;');
  FPack.Add('  var ops = divider !== -1 ? [fragments.slice(0, ');
  FPack.Add('divider).concat([fragments[divider].split(splitRegex)[0]]), ');
  FPack.Add('[fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] ');
  FPack.Add(': [fragments];');
  FPack.Add('');
  FPack.Add('  // Convert the values with units to absolute pixels to allow our computations');
  FPack.Add('  ops = ops.map(function (op, index) {');
  FPack.Add('    // Most of the units rely on the orientation of the popper');
  FPack.Add('    var measurement = (index === 1 ? !useHeight : useHeight) ? ''height'' : ');
  FPack.Add('''width'';');
  FPack.Add('    var mergeWithPrevious = false;');
  FPack.Add('    return op');
  FPack.Add('    // This aggregates any `+` or `-` sign that aren''t considered operators');
  FPack.Add('    // e.g.: 10 + +5 => [10, +, +5]');
  FPack.Add('    .reduce(function (a, b) {');
  FPack.Add('      if (a[a.length - 1] === '''' && [''+'', ''-''].indexOf(b) !== -1) {');
  FPack.Add('        a[a.length - 1] = b;');
  FPack.Add('        mergeWithPrevious = true;');
  FPack.Add('        return a;');
  FPack.Add('      } else if (mergeWithPrevious) {');
  FPack.Add('        a[a.length - 1] += b;');
  FPack.Add('        mergeWithPrevious = false;');
  FPack.Add('        return a;');
  FPack.Add('      } else {');
  FPack.Add('        return a.concat(b);');
  FPack.Add('      }');
  FPack.Add('    }, [])');
  FPack.Add('    // Here we convert the string values into number values (in px)');
  FPack.Add('    .map(function (str) {');
  FPack.Add('      return toValue(str, measurement, popperOffsets, referenceOffsets);');
  FPack.Add('    });');
  FPack.Add('  });');
  FPack.Add('');
  FPack.Add('  // Loop trough the offsets arrays and execute the operations');
  FPack.Add('  ops.forEach(function (op, index) {');
  FPack.Add('    op.forEach(function (frag, index2) {');
  FPack.Add('      if (isNumeric(frag)) {');
  FPack.Add('        offsets[index] += frag * (op[index2 - 1] === ''-'' ? -1 : 1);');
  FPack.Add('      }');
  FPack.Add('    });');
  FPack.Add('  });');
  FPack.Add('  return offsets;');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * @function');
  FPack.Add(' * @memberof Modifiers');
  FPack.Add(' * @argument {Object} data - The data object generated by update method');
  FPack.Add(' * @argument {Object} options - Modifiers configuration and options');
  FPack.Add(' * @argument {Number|String} options.offset=0');
  FPack.Add(' * The offset value as described in the modifier description');
  FPack.Add(' * @returns {Object} The data object, properly modified');
  FPack.Add(' */');
  FPack.Add('function offset(data, _ref) {');
  FPack.Add('  var offset = _ref.offset;');
  FPack.Add('  var placement = data.placement,');
  FPack.Add('      _data$offsets = data.offsets,');
  FPack.Add('      popper = _data$offsets.popper,');
  FPack.Add('      reference = _data$offsets.reference;');
  FPack.Add('');
  FPack.Add('  var basePlacement = placement.split(''-'')[0];');
  FPack.Add('');
  FPack.Add('  var offsets = void 0;');
  FPack.Add('  if (isNumeric(+offset)) {');
  FPack.Add('    offsets = [+offset, 0];');
  FPack.Add('  } else {');
  FPack.Add('    offsets = parseOffset(offset, popper, reference, basePlacement);');
  FPack.Add('  }');
  FPack.Add('');
  FPack.Add('  if (basePlacement === ''left'') {');
  FPack.Add('    popper.top += offsets[0];');
  FPack.Add('    popper.left -= offsets[1];');
  FPack.Add('  } else if (basePlacement === ''right'') {');
  FPack.Add('    popper.top += offsets[0];');
  FPack.Add('    popper.left += offsets[1];');
  FPack.Add('  } else if (basePlacement === ''top'') {');
  FPack.Add('    popper.left += offsets[0];');
  FPack.Add('    popper.top -= offsets[1];');
  FPack.Add('  } else if (basePlacement === ''bottom'') {');
  FPack.Add('    popper.left += offsets[0];');
  FPack.Add('    popper.top += offsets[1];');
  FPack.Add('  }');
  FPack.Add('');
  FPack.Add('  data.popper = popper;');
  FPack.Add('  return data;');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * @function');
  FPack.Add(' * @memberof Modifiers');
  FPack.Add(' * @argument {Object} data - The data object generated by `update` method');
  FPack.Add(' * @argument {Object} options - Modifiers configuration and options');
  FPack.Add(' * @returns {Object} The data object, properly modified');
  FPack.Add(' */');
  FPack.Add('function preventOverflow(data, options) {');
  FPack.Add('  var boundariesElement = options.boundariesElement || ');
  FPack.Add('getOffsetParent(data.instance.popper);');
  FPack.Add('');
  FPack.Add('  // If offsetParent is the reference element, we really want to');
  FPack.Add('  // go one step up and use the next offsetParent as reference to');
  FPack.Add('  // avoid to make this modifier completely useless and look like broken');
  FPack.Add('  if (data.instance.reference === boundariesElement) {');
  FPack.Add('    boundariesElement = getOffsetParent(boundariesElement);');
  FPack.Add('  }');
  FPack.Add('');
  FPack.Add('  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, ');
  FPack.Add('options.padding, boundariesElement);');
  FPack.Add('  options.boundaries = boundaries;');
  FPack.Add('');
  FPack.Add('  var order = options.priority;');
  FPack.Add('  var popper = data.offsets.popper;');
  FPack.Add('');
  FPack.Add('  var check = {');
  FPack.Add('    primary: function primary(placement) {');
  FPack.Add('      var value = popper[placement];');
  FPack.Add('      if (popper[placement] < boundaries[placement] && ');
  FPack.Add('!options.escapeWithReference) {');
  FPack.Add('        value = Math.max(popper[placement], boundaries[placement]);');
  FPack.Add('      }');
  FPack.Add('      return defineProperty({}, placement, value);');
  FPack.Add('    },');
  FPack.Add('    secondary: function secondary(placement) {');
  FPack.Add('      var mainSide = placement === ''right'' ? ''left'' : ''top'';');
  FPack.Add('      var value = popper[mainSide];');
  FPack.Add('      if (popper[placement] > boundaries[placement] && ');
  FPack.Add('!options.escapeWithReference) {');
  FPack.Add('        value = Math.min(popper[mainSide], boundaries[placement] - (placement ');
  FPack.Add('=== ''right'' ? popper.width : popper.height));');
  FPack.Add('      }');
  FPack.Add('      return defineProperty({}, mainSide, value);');
  FPack.Add('    }');
  FPack.Add('  };');
  FPack.Add('');
  FPack.Add('  order.forEach(function (placement) {');
  FPack.Add('    var side = [''left'', ''top''].indexOf(placement) !== -1 ? ''primary'' : ');
  FPack.Add('''secondary'';');
  FPack.Add('    popper = _extends({}, popper, check[side](placement));');
  FPack.Add('  });');
  FPack.Add('');
  FPack.Add('  data.offsets.popper = popper;');
  FPack.Add('');
  FPack.Add('  return data;');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * @function');
  FPack.Add(' * @memberof Modifiers');
  FPack.Add(' * @argument {Object} data - The data object generated by `update` method');
  FPack.Add(' * @argument {Object} options - Modifiers configuration and options');
  FPack.Add(' * @returns {Object} The data object, properly modified');
  FPack.Add(' */');
  FPack.Add('function shift(data) {');
  FPack.Add('  var placement = data.placement;');
  FPack.Add('  var basePlacement = placement.split(''-'')[0];');
  FPack.Add('  var shiftvariation = placement.split(''-'')[1];');
  FPack.Add('');
  FPack.Add('  // if shift shiftvariation is specified, run the modifier');
  FPack.Add('  if (shiftvariation) {');
  FPack.Add('    var _data$offsets = data.offsets,');
  FPack.Add('        reference = _data$offsets.reference,');
  FPack.Add('        popper = _data$offsets.popper;');
  FPack.Add('');
  FPack.Add('    var isVertical = [''bottom'', ''top''].indexOf(basePlacement) !== -1;');
  FPack.Add('    var side = isVertical ? ''left'' : ''top'';');
  FPack.Add('    var measurement = isVertical ? ''width'' : ''height'';');
  FPack.Add('');
  FPack.Add('    var shiftOffsets = {');
  FPack.Add('      start: defineProperty({}, side, reference[side]),');
  FPack.Add('      end: defineProperty({}, side, reference[side] + reference[measurement] - ');
  FPack.Add('popper[measurement])');
  FPack.Add('    };');
  FPack.Add('');
  FPack.Add('    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);');
  FPack.Add('  }');
  FPack.Add('');
  FPack.Add('  return data;');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * @function');
  FPack.Add(' * @memberof Modifiers');
  FPack.Add(' * @argument {Object} data - The data object generated by update method');
  FPack.Add(' * @argument {Object} options - Modifiers configuration and options');
  FPack.Add(' * @returns {Object} The data object, properly modified');
  FPack.Add(' */');
  FPack.Add('function hide(data) {');
  FPack.Add('  if (!isModifierRequired(data.instance.modifiers, ''hide'', ''preventOverflow'')) {');
  FPack.Add('    return data;');
  FPack.Add('  }');
  FPack.Add('');
  FPack.Add('  var refRect = data.offsets.reference;');
  FPack.Add('  var bound = find(data.instance.modifiers, function (modifier) {');
  FPack.Add('    return modifier.name === ''preventOverflow'';');
  FPack.Add('  }).boundaries;');
  FPack.Add('');
  FPack.Add('  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > ');
  FPack.Add('bound.bottom || refRect.right < bound.left) {');
  FPack.Add('    // Avoid unnecessary DOM access if visibility hasn''t changed');
  FPack.Add('    if (data.hide === true) {');
  FPack.Add('      return data;');
  FPack.Add('    }');
  FPack.Add('');
  FPack.Add('    data.hide = true;');
  FPack.Add('    data.attributes[''x-out-of-boundaries''] = '''';');
  FPack.Add('  } else {');
  FPack.Add('    // Avoid unnecessary DOM access if visibility hasn''t changed');
  FPack.Add('    if (data.hide === false) {');
  FPack.Add('      return data;');
  FPack.Add('    }');
  FPack.Add('');
  FPack.Add('    data.hide = false;');
  FPack.Add('    data.attributes[''x-out-of-boundaries''] = false;');
  FPack.Add('  }');
  FPack.Add('');
  FPack.Add('  return data;');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * @function');
  FPack.Add(' * @memberof Modifiers');
  FPack.Add(' * @argument {Object} data - The data object generated by `update` method');
  FPack.Add(' * @argument {Object} options - Modifiers configuration and options');
  FPack.Add(' * @returns {Object} The data object, properly modified');
  FPack.Add(' */');
  FPack.Add('function inner(data) {');
end;

procedure TPopperJS.PopperJS_7;
begin
  FPack.Add('  var placement = data.placement;');
  FPack.Add('  var basePlacement = placement.split(''-'')[0];');
  FPack.Add('  var _data$offsets = data.offsets,');
  FPack.Add('      popper = _data$offsets.popper,');
  FPack.Add('      reference = _data$offsets.reference;');
  FPack.Add('');
  FPack.Add('  var isHoriz = [''left'', ''right''].indexOf(basePlacement) !== -1;');
  FPack.Add('');
  FPack.Add('  var subtractLength = [''top'', ''left''].indexOf(basePlacement) === -1;');
  FPack.Add('');
  FPack.Add('  popper[isHoriz ? ''left'' : ''top''] = reference[basePlacement] - (subtractLength ');
  FPack.Add('? popper[isHoriz ? ''width'' : ''height''] : 0);');
  FPack.Add('');
  FPack.Add('  data.placement = getOppositePlacement(placement);');
  FPack.Add('  data.offsets.popper = getClientRect(popper);');
  FPack.Add('');
  FPack.Add('  return data;');
  FPack.Add('}');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * Modifier function, each modifier can have a function of this type assigned');
  FPack.Add(' * to its `fn` property.<br />');
  FPack.Add(' * These functions will be called on each update, this means that you must');
  FPack.Add(' * make sure they are performant enough to avoid performance bottlenecks.');
  FPack.Add(' *');
  FPack.Add(' * @function ModifierFn');
  FPack.Add(' * @argument {dataObject} data - The data object generated by `update` method');
  FPack.Add(' * @argument {Object} options - Modifiers configuration and options');
  FPack.Add(' * @returns {dataObject} The data object, properly modified');
  FPack.Add(' */');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * Modifiers are plugins used to alter the behavior of your poppers.<br />');
  FPack.Add(' * Popper.js uses a set of 9 modifiers to provide all the basic functionalities');
  FPack.Add(' * needed by the library.');
  FPack.Add(' *');
  FPack.Add(' * Usually you don''t want to override the `order`, `fn` and `onLoad` props.');
  FPack.Add(' * All the other properties are configurations that could be tweaked.');
  FPack.Add(' * @namespace modifiers');
  FPack.Add(' */');
  FPack.Add('var modifiers = {');
  FPack.Add('  /**');
  FPack.Add('   * Modifier used to shift the popper on the start or end of its reference');
  FPack.Add('   * element.<br />');
  FPack.Add('   * It will read the variation of the `placement` property.<br />');
  FPack.Add('   * It can be one either `-end` or `-start`.');
  FPack.Add('   * @memberof modifiers');
  FPack.Add('   * @inner');
  FPack.Add('   */');
  FPack.Add('  shift: {');
  FPack.Add('    /** @prop {number} order=100 - Index used to define the order of execution ');
  FPack.Add('*/');
  FPack.Add('    order: 100,');
  FPack.Add('    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */');
  FPack.Add('    enabled: true,');
  FPack.Add('    /** @prop {ModifierFn} */');
  FPack.Add('    fn: shift');
  FPack.Add('  },');
  FPack.Add('');
  FPack.Add('  /**');
  FPack.Add('   * The `offset` modifier can shift your popper on both its axis.');
  FPack.Add('   *');
  FPack.Add('   * It accepts the following units:');
  FPack.Add('   * - `px` or unitless, interpreted as pixels');
  FPack.Add('   * - `%` or `%r`, percentage relative to the length of the reference element');
  FPack.Add('   * - `%p`, percentage relative to the length of the popper element');
  FPack.Add('   * - `vw`, CSS viewport width unit');
  FPack.Add('   * - `vh`, CSS viewport height unit');
  FPack.Add('   *');
  FPack.Add('   * For length is intended the main axis relative to the placement of the ');
  FPack.Add('popper.<br />');
  FPack.Add('   * This means that if the placement is `top` or `bottom`, the length will be ');
  FPack.Add('the');
  FPack.Add('   * `width`. In case of `left` or `right`, it will be the height.');
  FPack.Add('   *');
  FPack.Add('   * You can provide a single value (as `Number` or `String`), or a pair of ');
  FPack.Add('values');
  FPack.Add('   * as `String` divided by a comma or one (or more) white spaces.<br />');
  FPack.Add('   * The latter is a deprecated method because it leads to confusion and will be');
  FPack.Add('   * removed in v2.<br />');
  FPack.Add('   * Additionally, it accepts additions and subtractions between different ');
  FPack.Add('units.');
  FPack.Add('   * Note that multiplications and divisions aren''t supported.');
  FPack.Add('   *');
  FPack.Add('   * Valid examples are:');
  FPack.Add('   * ```');
  FPack.Add('   * 10');
  FPack.Add('   * ''10%''');
  FPack.Add('   * ''10, 10''');
  FPack.Add('   * ''10%, 10''');
  FPack.Add('   * ''10 + 10%''');
  FPack.Add('   * ''10 - 5vh + 3%''');
  FPack.Add('   * ''-10px + 5vh, 5px - 6%''');
  FPack.Add('   * ```');
  FPack.Add('   * > **NB**: If you desire to apply offsets to your poppers in a way that may ');
  FPack.Add('make them overlap');
  FPack.Add('   * > with their reference element, unfortunately, you will have to disable ');
  FPack.Add('the `flip` modifier.');
  FPack.Add('   * > More on this [reading this ');
  FPack.Add('issue](https://github.com/FezVrasta/popper.js/issues/373)');
  FPack.Add('   *');
  FPack.Add('   * @memberof modifiers');
  FPack.Add('   * @inner');
  FPack.Add('   */');
  FPack.Add('  offset: {');
  FPack.Add('    /** @prop {number} order=200 - Index used to define the order of execution ');
  FPack.Add('*/');
  FPack.Add('    order: 200,');
  FPack.Add('    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */');
  FPack.Add('    enabled: true,');
  FPack.Add('    /** @prop {ModifierFn} */');
  FPack.Add('    fn: offset,');
  FPack.Add('    /** @prop {Number|String} offset=0');
  FPack.Add('     * The offset value as described in the modifier description');
  FPack.Add('     */');
  FPack.Add('    offset: 0');
  FPack.Add('  },');
  FPack.Add('');
  FPack.Add('  /**');
  FPack.Add('   * Modifier used to prevent the popper from being positioned outside the ');
  FPack.Add('boundary.');
  FPack.Add('   *');
  FPack.Add('   * An scenario exists where the reference itself is not within the ');
  FPack.Add('boundaries.<br />');
  FPack.Add('   * We can say it has "escaped the boundaries" — or just "escaped".<br />');
  FPack.Add('   * In this case we need to decide whether the popper should either:');
  FPack.Add('   *');
  FPack.Add('   * - detach from the reference and remain "trapped" in the boundaries, or');
  FPack.Add('   * - if it should ignore the boundary and "escape with its reference"');
  FPack.Add('   *');
  FPack.Add('   * When `escapeWithReference` is set to`true` and reference is completely');
  FPack.Add('   * outside its boundaries, the popper will overflow (or completely leave)');
  FPack.Add('   * the boundaries in order to remain attached to the edge of the reference.');
  FPack.Add('   *');
  FPack.Add('   * @memberof modifiers');
  FPack.Add('   * @inner');
  FPack.Add('   */');
  FPack.Add('  preventOverflow: {');
  FPack.Add('    /** @prop {number} order=300 - Index used to define the order of execution ');
  FPack.Add('*/');
  FPack.Add('    order: 300,');
  FPack.Add('    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */');
  FPack.Add('    enabled: true,');
  FPack.Add('    /** @prop {ModifierFn} */');
  FPack.Add('    fn: preventOverflow,');
  FPack.Add('    /**');
  FPack.Add('     * @prop {Array} [priority=[''left'',''right'',''top'',''bottom'']]');
  FPack.Add('     * Popper will try to prevent overflow following these priorities by ');
  FPack.Add('default,');
  FPack.Add('     * then, it could overflow on the left and on top of the `boundariesElement`');
  FPack.Add('     */');
  FPack.Add('    priority: [''left'', ''right'', ''top'', ''bottom''],');
  FPack.Add('    /**');
  FPack.Add('     * @prop {number} padding=5');
  FPack.Add('     * Amount of pixel used to define a minimum distance between the boundaries');
  FPack.Add('     * and the popper this makes sure the popper has always a little padding');
  FPack.Add('     * between the edges of its container');
  FPack.Add('     */');
  FPack.Add('    padding: 5,');
  FPack.Add('    /**');
  FPack.Add('     * @prop {String|HTMLElement} boundariesElement=''scrollParent''');
  FPack.Add('     * Boundaries used by the modifier, can be `scrollParent`, `window`,');
  FPack.Add('     * `viewport` or any DOM element.');
  FPack.Add('     */');
  FPack.Add('    boundariesElement: ''scrollParent''');
  FPack.Add('  },');
  FPack.Add('');
  FPack.Add('  /**');
  FPack.Add('   * Modifier used to make sure the reference and its popper stay near ');
  FPack.Add('eachothers');
  FPack.Add('   * without leaving any gap between the two. Expecially useful when the arrow ');
  FPack.Add('is');
  FPack.Add('   * enabled and you want to assure it to point to its reference element.');
  FPack.Add('   * It cares only about the first axis, you can still have poppers with margin');
  FPack.Add('   * between the popper and its reference element.');
  FPack.Add('   * @memberof modifiers');
  FPack.Add('   * @inner');
  FPack.Add('   */');
  FPack.Add('  keepTogether: {');
  FPack.Add('    /** @prop {number} order=400 - Index used to define the order of execution ');
  FPack.Add('*/');
  FPack.Add('    order: 400,');
  FPack.Add('    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */');
  FPack.Add('    enabled: true,');
  FPack.Add('    /** @prop {ModifierFn} */');
  FPack.Add('    fn: keepTogether');
  FPack.Add('  },');
  FPack.Add('');
  FPack.Add('  /**');
  FPack.Add('   * This modifier is used to move the `arrowElement` of the popper to make');
  FPack.Add('   * sure it is positioned between the reference element and its popper element.');
  FPack.Add('   * It will read the outer size of the `arrowElement` node to detect how many');
  FPack.Add('   * pixels of conjuction are needed.');
  FPack.Add('   *');
  FPack.Add('   * It has no effect if no `arrowElement` is provided.');
  FPack.Add('   * @memberof modifiers');
  FPack.Add('   * @inner');
  FPack.Add('   */');
  FPack.Add('  arrow: {');
  FPack.Add('    /** @prop {number} order=500 - Index used to define the order of execution ');
  FPack.Add('*/');
  FPack.Add('    order: 500,');
  FPack.Add('    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */');
  FPack.Add('    enabled: true,');
  FPack.Add('    /** @prop {ModifierFn} */');
  FPack.Add('    fn: arrow,');
  FPack.Add('    /** @prop {String|HTMLElement} element=''[x-arrow]'' - Selector or node used ');
  FPack.Add('as arrow */');
  FPack.Add('    element: ''[x-arrow]''');
  FPack.Add('  },');
  FPack.Add('');
  FPack.Add('  /**');
  FPack.Add('   * Modifier used to flip the popper''s placement when it starts to overlap its');
  FPack.Add('   * reference element.');
  FPack.Add('   *');
  FPack.Add('   * Requires the `preventOverflow` modifier before it in order to work.');
  FPack.Add('   *');
  FPack.Add('   * **NOTE:** this modifier will interrupt the current update cycle and will');
  FPack.Add('   * restart it if it detects the need to flip the placement.');
  FPack.Add('   * @memberof modifiers');
  FPack.Add('   * @inner');
  FPack.Add('   */');
  FPack.Add('  flip: {');
  FPack.Add('    /** @prop {number} order=600 - Index used to define the order of execution ');
  FPack.Add('*/');
  FPack.Add('    order: 600,');
  FPack.Add('    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */');
  FPack.Add('    enabled: true,');
  FPack.Add('    /** @prop {ModifierFn} */');
  FPack.Add('    fn: flip,');
  FPack.Add('    /**');
  FPack.Add('     * @prop {String|Array} behavior=''flip''');
  FPack.Add('     * The behavior used to change the popper''s placement. It can be one of');
  FPack.Add('     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid');
  FPack.Add('     * placements (with optional variations).');
  FPack.Add('     */');
  FPack.Add('    behavior: ''flip'',');
  FPack.Add('    /**');
  FPack.Add('     * @prop {number} padding=5');
  FPack.Add('     * The popper will flip if it hits the edges of the `boundariesElement`');
  FPack.Add('     */');
  FPack.Add('    padding: 5,');
  FPack.Add('    /**');
  FPack.Add('     * @prop {String|HTMLElement} boundariesElement=''viewport''');
  FPack.Add('     * The element which will define the boundaries of the popper position,');
  FPack.Add('     * the popper will never be placed outside of the defined boundaries');
  FPack.Add('     * (except if keepTogether is enabled)');
  FPack.Add('     */');
  FPack.Add('    boundariesElement: ''viewport''');
  FPack.Add('  },');
  FPack.Add('');
  FPack.Add('  /**');
  FPack.Add('   * Modifier used to make the popper flow toward the inner of the reference ');
  FPack.Add('element.');
  FPack.Add('   * By default, when this modifier is disabled, the popper will be placed ');
  FPack.Add('outside');
  FPack.Add('   * the reference element.');
  FPack.Add('   * @memberof modifiers');
  FPack.Add('   * @inner');
  FPack.Add('   */');
  FPack.Add('  inner: {');
  FPack.Add('    /** @prop {number} order=700 - Index used to define the order of execution ');
  FPack.Add('*/');
  FPack.Add('    order: 700,');
  FPack.Add('    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not ');
  FPack.Add('*/');
  FPack.Add('    enabled: false,');
  FPack.Add('    /** @prop {ModifierFn} */');
  FPack.Add('    fn: inner');
  FPack.Add('  },');
  FPack.Add('');
  FPack.Add('  /**');
  FPack.Add('   * Modifier used to hide the popper when its reference element is outside of ');
  FPack.Add('the');
  FPack.Add('   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can');
  FPack.Add('   * be used to hide with a CSS selector the popper when its reference is');
  FPack.Add('   * out of boundaries.');
  FPack.Add('   *');
  FPack.Add('   * Requires the `preventOverflow` modifier before it in order to work.');
  FPack.Add('   * @memberof modifiers');
  FPack.Add('   * @inner');
  FPack.Add('   */');
  FPack.Add('  hide: {');
  FPack.Add('    /** @prop {number} order=800 - Index used to define the order of execution ');
  FPack.Add('*/');
  FPack.Add('    order: 800,');
  FPack.Add('    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */');
  FPack.Add('    enabled: true,');
  FPack.Add('    /** @prop {ModifierFn} */');
  FPack.Add('    fn: hide');
  FPack.Add('  },');
  FPack.Add('');
  FPack.Add('  /**');
  FPack.Add('   * Computes the style that will be applied to the popper element to gets');
  FPack.Add('   * properly positioned.');
  FPack.Add('   *');
  FPack.Add('   * Note that this modifier will not touch the DOM, it just prepares the styles');
  FPack.Add('   * so that `applyStyle` modifier can apply it. This separation is useful');
  FPack.Add('   * in case you need to replace `applyStyle` with a custom implementation.');
  FPack.Add('   *');
  FPack.Add('   * This modifier has `850` as `order` value to maintain backward compatibility');
  FPack.Add('   * with previous versions of Popper.js. Expect the modifiers ordering method');
  FPack.Add('   * to change in future major versions of the library.');
  FPack.Add('   *');
  FPack.Add('   * @memberof modifiers');
  FPack.Add('   * @inner');
  FPack.Add('   */');
  FPack.Add('  computeStyle: {');
  FPack.Add('    /** @prop {number} order=850 - Index used to define the order of execution ');
  FPack.Add('*/');
  FPack.Add('    order: 850,');
  FPack.Add('    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */');
  FPack.Add('    enabled: true,');
  FPack.Add('    /** @prop {ModifierFn} */');
  FPack.Add('    fn: computeStyle,');
  FPack.Add('    /**');
  FPack.Add('     * @prop {Boolean} gpuAcceleration=true');
  FPack.Add('     * If true, it uses the CSS 3d transformation to position the popper.');
  FPack.Add('     * Otherwise, it will use the `top` and `left` properties.');
  FPack.Add('     */');
  FPack.Add('    gpuAcceleration: true,');
  FPack.Add('    /**');
  FPack.Add('     * @prop {string} [x=''bottom'']');
  FPack.Add('     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.');
  FPack.Add('     * Change this if your popper should grow in a direction different from ');
  FPack.Add('`bottom`');
  FPack.Add('     */');
  FPack.Add('    x: ''bottom'',');
  FPack.Add('    /**');
  FPack.Add('     * @prop {string} [x=''left'']');
  FPack.Add('     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.');
  FPack.Add('     * Change this if your popper should grow in a direction different from ');
  FPack.Add('`right`');
  FPack.Add('     */');
  FPack.Add('    y: ''right''');
  FPack.Add('  },');
end;

procedure TPopperJS.PopperJS_8;
begin
  FPack.Add('');
  FPack.Add('  /**');
  FPack.Add('   * Applies the computed styles to the popper element.');
  FPack.Add('   *');
  FPack.Add('   * All the DOM manipulations are limited to this modifier. This is useful in ');
  FPack.Add('case');
  FPack.Add('   * you want to integrate Popper.js inside a framework or view library and you');
  FPack.Add('   * want to delegate all the DOM manipulations to it.');
  FPack.Add('   *');
  FPack.Add('   * Note that if you disable this modifier, you must make sure the popper ');
  FPack.Add('element');
  FPack.Add('   * has its position set to `absolute` before Popper.js can do its work!');
  FPack.Add('   *');
  FPack.Add('   * Just disable this modifier and define you own to achieve the desired ');
  FPack.Add('effect.');
  FPack.Add('   *');
  FPack.Add('   * @memberof modifiers');
  FPack.Add('   * @inner');
  FPack.Add('   */');
  FPack.Add('  applyStyle: {');
  FPack.Add('    /** @prop {number} order=900 - Index used to define the order of execution ');
  FPack.Add('*/');
  FPack.Add('    order: 900,');
  FPack.Add('    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */');
  FPack.Add('    enabled: true,');
  FPack.Add('    /** @prop {ModifierFn} */');
  FPack.Add('    fn: applyStyle,');
  FPack.Add('    /** @prop {Function} */');
  FPack.Add('    onLoad: applyStyleOnLoad,');
  FPack.Add('    /**');
  FPack.Add('     * @deprecated since version 1.10.0, the property moved to `computeStyle` ');
  FPack.Add('modifier');
  FPack.Add('     * @prop {Boolean} gpuAcceleration=true');
  FPack.Add('     * If true, it uses the CSS 3d transformation to position the popper.');
  FPack.Add('     * Otherwise, it will use the `top` and `left` properties.');
  FPack.Add('     */');
  FPack.Add('    gpuAcceleration: undefined');
  FPack.Add('  }');
  FPack.Add('};');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * The `dataObject` is an object containing all the informations used by ');
  FPack.Add('Popper.js');
  FPack.Add(' * this object get passed to modifiers and to the `onCreate` and `onUpdate` ');
  FPack.Add('callbacks.');
  FPack.Add(' * @name dataObject');
  FPack.Add(' * @property {Object} data.instance The Popper.js instance');
  FPack.Add(' * @property {String} data.placement Placement applied to popper');
  FPack.Add(' * @property {String} data.originalPlacement Placement originally defined on ');
  FPack.Add('init');
  FPack.Add(' * @property {Boolean} data.flipped True if popper has been flipped by flip ');
  FPack.Add('modifier');
  FPack.Add(' * @property {Boolean} data.hide True if the reference element is out of ');
  FPack.Add('boundaries, useful to know when to hide the popper.');
  FPack.Add(' * @property {HTMLElement} data.arrowElement Node used as arrow by arrow ');
  FPack.Add('modifier');
  FPack.Add(' * @property {Object} data.styles Any CSS property defined here will be applied ');
  FPack.Add('to the popper, it expects the JavaScript nomenclature (eg. `marginBottom`)');
  FPack.Add(' * @property {Object} data.arrowStyles Any CSS property defined here will be ');
  FPack.Add('applied to the popper arrow, it expects the JavaScript nomenclature (eg. ');
  FPack.Add('`marginBottom`)');
  FPack.Add(' * @property {Object} data.boundaries Offsets of the popper boundaries');
  FPack.Add(' * @property {Object} data.offsets The measurements of popper, reference and ');
  FPack.Add('arrow elements.');
  FPack.Add(' * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` ');
  FPack.Add('values');
  FPack.Add(' * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` ');
  FPack.Add('values');
  FPack.Add(' * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of ');
  FPack.Add('them will be different from 0');
  FPack.Add(' */');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * Default options provided to Popper.js constructor.<br />');
  FPack.Add(' * These can be overriden using the `options` argument of Popper.js.<br />');
  FPack.Add(' * To override an option, simply pass as 3rd argument an object with the same');
  FPack.Add(' * structure of this object, example:');
  FPack.Add(' * ```');
  FPack.Add(' * new Popper(ref, pop, {');
  FPack.Add(' *   modifiers: {');
  FPack.Add(' *     preventOverflow: { enabled: false }');
  FPack.Add(' *   }');
  FPack.Add(' * })');
  FPack.Add(' * ```');
  FPack.Add(' * @type {Object}');
  FPack.Add(' * @static');
  FPack.Add(' * @memberof Popper');
  FPack.Add(' */');
  FPack.Add('var Defaults = {');
  FPack.Add('  /**');
  FPack.Add('   * Popper''s placement');
  FPack.Add('   * @prop {Popper.placements} placement=''bottom''');
  FPack.Add('   */');
  FPack.Add('  placement: ''bottom'',');
  FPack.Add('');
  FPack.Add('  /**');
  FPack.Add('   * Whether events (resize, scroll) are initially enabled');
  FPack.Add('   * @prop {Boolean} eventsEnabled=true');
  FPack.Add('   */');
  FPack.Add('  eventsEnabled: true,');
  FPack.Add('');
  FPack.Add('  /**');
  FPack.Add('   * Set to true if you want to automatically remove the popper when');
  FPack.Add('   * you call the `destroy` method.');
  FPack.Add('   * @prop {Boolean} removeOnDestroy=false');
  FPack.Add('   */');
  FPack.Add('  removeOnDestroy: false,');
  FPack.Add('');
  FPack.Add('  /**');
  FPack.Add('   * Callback called when the popper is created.<br />');
  FPack.Add('   * By default, is set to no-op.<br />');
  FPack.Add('   * Access Popper.js instance with `data.instance`.');
  FPack.Add('   * @prop {onCreate}');
  FPack.Add('   */');
  FPack.Add('  onCreate: function onCreate() {},');
  FPack.Add('');
  FPack.Add('  /**');
  FPack.Add('   * Callback called when the popper is updated, this callback is not called');
  FPack.Add('   * on the initialization/creation of the popper, but only on subsequent');
  FPack.Add('   * updates.<br />');
  FPack.Add('   * By default, is set to no-op.<br />');
  FPack.Add('   * Access Popper.js instance with `data.instance`.');
  FPack.Add('   * @prop {onUpdate}');
  FPack.Add('   */');
  FPack.Add('  onUpdate: function onUpdate() {},');
  FPack.Add('');
  FPack.Add('  /**');
  FPack.Add('   * List of modifiers used to modify the offsets before they are applied to ');
  FPack.Add('the popper.');
  FPack.Add('   * They provide most of the functionalities of Popper.js');
  FPack.Add('   * @prop {modifiers}');
  FPack.Add('   */');
  FPack.Add('  modifiers: modifiers');
  FPack.Add('};');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * @callback onCreate');
  FPack.Add(' * @param {dataObject} data');
  FPack.Add(' */');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * @callback onUpdate');
  FPack.Add(' * @param {dataObject} data');
  FPack.Add(' */');
  FPack.Add('');
  FPack.Add('// Utils');
  FPack.Add('// Methods');
  FPack.Add('var Popper = function () {');
  FPack.Add('  /**');
  FPack.Add('   * Create a new Popper.js instance');
  FPack.Add('   * @class Popper');
  FPack.Add('   * @param {HTMLElement|referenceObject} reference - The reference element ');
  FPack.Add('used to position the popper');
  FPack.Add('   * @param {HTMLElement} popper - The HTML element used as popper.');
  FPack.Add('   * @param {Object} options - Your custom options to override the ones defined ');
  FPack.Add('in [Defaults](#defaults)');
  FPack.Add('   * @return {Object} instance - The generated Popper.js instance');
  FPack.Add('   */');
  FPack.Add('  function Popper(reference, popper) {');
  FPack.Add('    var _this = this;');
  FPack.Add('');
  FPack.Add('    var options = arguments.length > 2 && arguments[2] !== undefined ? ');
  FPack.Add('arguments[2] : {};');
  FPack.Add('    classCallCheck(this, Popper);');
  FPack.Add('');
  FPack.Add('    this.scheduleUpdate = function () {');
  FPack.Add('      return requestAnimationFrame(_this.update);');
  FPack.Add('    };');
  FPack.Add('');
  FPack.Add('    // make update() debounced, so that it only runs at most once-per-tick');
  FPack.Add('    this.update = debounce(this.update.bind(this));');
  FPack.Add('');
  FPack.Add('    // with {} we create a new object with the options inside it');
  FPack.Add('    this.options = _extends({}, Popper.Defaults, options);');
  FPack.Add('');
  FPack.Add('    // init state');
  FPack.Add('    this.state = {');
  FPack.Add('      isDestroyed: false,');
  FPack.Add('      isCreated: false,');
  FPack.Add('      scrollParents: []');
  FPack.Add('    };');
  FPack.Add('');
  FPack.Add('    // get reference and popper elements (allow jQuery wrappers)');
  FPack.Add('    this.reference = reference && reference.jquery ? reference[0] : reference;');
  FPack.Add('    this.popper = popper && popper.jquery ? popper[0] : popper;');
  FPack.Add('');
  FPack.Add('    // Deep merge modifiers options');
  FPack.Add('    this.options.modifiers = {};');
  FPack.Add('    Object.keys(_extends({}, Popper.Defaults.modifiers, ');
  FPack.Add('options.modifiers)).forEach(function (name) {');
  FPack.Add('      _this.options.modifiers[name] = _extends({}, ');
  FPack.Add('Popper.Defaults.modifiers[name] || {}, options.modifiers ? ');
  FPack.Add('options.modifiers[name] : {});');
  FPack.Add('    });');
  FPack.Add('');
  FPack.Add('    // Refactoring modifiers'' list (Object => Array)');
  FPack.Add('    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {');
  FPack.Add('      return _extends({');
  FPack.Add('        name: name');
  FPack.Add('      }, _this.options.modifiers[name]);');
  FPack.Add('    })');
  FPack.Add('    // sort the modifiers by order');
  FPack.Add('    .sort(function (a, b) {');
  FPack.Add('      return a.order - b.order;');
  FPack.Add('    });');
  FPack.Add('');
  FPack.Add('    // modifiers have the ability to execute arbitrary code when Popper.js get ');
  FPack.Add('inited');
  FPack.Add('    // such code is executed in the same order of its modifier');
  FPack.Add('    // they could add new properties to their options configuration');
  FPack.Add('    // BE AWARE: don''t add options to `options.modifiers.name` but to `modifierOptions`!');
  FPack.Add('    this.modifiers.forEach(function (modifierOptions) {');
  FPack.Add('      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {');
  FPack.Add('        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, ');
  FPack.Add('modifierOptions, _this.state);');
  FPack.Add('      }');
  FPack.Add('    });');
  FPack.Add('');
  FPack.Add('    // fire the first update to position the popper in the right place');
  FPack.Add('    this.update();');
  FPack.Add('');
  FPack.Add('    var eventsEnabled = this.options.eventsEnabled;');
  FPack.Add('    if (eventsEnabled) {');
  FPack.Add('      // setup event listeners, they will take care of update the position in '
  + 'specific situations');
  FPack.Add('      this.enableEventListeners();');
  FPack.Add('    }');
  FPack.Add('');
  FPack.Add('    this.state.eventsEnabled = eventsEnabled;');
  FPack.Add('  }');
  FPack.Add('');
  FPack.Add('  // We can''t use class properties because they don''t get listed in the');
  FPack.Add('  // class prototype and break stuff like Sinon stubs');
  FPack.Add('');
  FPack.Add('');
  FPack.Add('  createClass(Popper, [{');
  FPack.Add('    key: ''update'',');
  FPack.Add('    value: function update$$1() {');
  FPack.Add('      return update.call(this);');
  FPack.Add('    }');
  FPack.Add('  }, {');
  FPack.Add('    key: ''destroy'',');
  FPack.Add('    value: function destroy$$1() {');
  FPack.Add('      return destroy.call(this);');
  FPack.Add('    }');
  FPack.Add('  }, {');
  FPack.Add('    key: ''enableEventListeners'',');
  FPack.Add('    value: function enableEventListeners$$1() {');
  FPack.Add('      return enableEventListeners.call(this);');
  FPack.Add('    }');
  FPack.Add('  }, {');
  FPack.Add('    key: ''disableEventListeners'',');
  FPack.Add('    value: function disableEventListeners$$1() {');
  FPack.Add('      return disableEventListeners.call(this);');
  FPack.Add('    }');
  FPack.Add('');
  FPack.Add('    /**');
  FPack.Add('     * Schedule an update, it will run on the next UI update available');
  FPack.Add('     * @method scheduleUpdate');
  FPack.Add('     * @memberof Popper');
  FPack.Add('     */');
  FPack.Add('');
  FPack.Add('');
  FPack.Add('    /**');
  FPack.Add('     * Collection of utilities useful when writing custom modifiers.');
  FPack.Add('     * Starting from version 1.7, this method is available only if you');
  FPack.Add('     * include `popper-utils.js` before `popper.js`.');
  FPack.Add('     *');
  FPack.Add('     * **DEPRECATION**: This way to access PopperUtils is deprecated');
  FPack.Add('     * and will be removed in v2! Use the PopperUtils module directly instead.');
  FPack.Add('     * Due to the high instability of the methods contained in Utils, we can''t');
  FPack.Add('     * guarantee them to follow semver. Use them at your own risk!');
  FPack.Add('     * @static');
  FPack.Add('     * @private');
  FPack.Add('     * @type {Object}');
  FPack.Add('     * @deprecated since version 1.8');
  FPack.Add('     * @member Utils');
  FPack.Add('     * @memberof Popper');
  FPack.Add('     */');
  FPack.Add('');
  FPack.Add('  }]);');
  FPack.Add('  return Popper;');
  FPack.Add('}();');
  FPack.Add('');
  FPack.Add('/**');
  FPack.Add(' * The `referenceObject` is an object that provides an interface compatible ');
  FPack.Add('with Popper.js');
  FPack.Add(' * and lets you use it as replacement of a real DOM node.<br />');
  FPack.Add(' * You can use this method to position a popper relatively to a set of ');
  FPack.Add('coordinates');
  FPack.Add(' * in case you don''t have a DOM node to use as reference.');
  FPack.Add(' *');
  FPack.Add(' * ```');
  FPack.Add(' * new Popper(referenceObject, popperNode);');
  FPack.Add(' * ```');
  FPack.Add(' *');
  FPack.Add(' * NB: This feature isn''t supported in Internet Explorer 10');
  FPack.Add(' * @name referenceObject');
  FPack.Add(' * @property {Function} data.getBoundingClientRect');
  FPack.Add(' * A function that returns a set of coordinates compatible with the native ');
  FPack.Add('`getBoundingClientRect` method.');
  FPack.Add(' * @property {number} data.clientWidth');
  FPack.Add(' * An ES6 getter that will return the width of the virtual reference element.');
  FPack.Add(' * @property {number} data.clientHeight');
  FPack.Add(' * An ES6 getter that will return the height of the virtual reference element.');
  FPack.Add(' */');
  FPack.Add('');
  FPack.Add('');
  FPack.Add('Popper.Utils = (typeof window !== ''undefined'' ? window : global).PopperUtils;');
  FPack.Add('Popper.placements = placements;');
  FPack.Add('Popper.Defaults = Defaults;');
  FPack.Add('');
  FPack.Add('return Popper;');
  FPack.Add('');
  FPack.Add('})));');
  FPack.Add('//# sourceMappingURL=popper.js.map');
  FPack.Add('</script>'+#13);
end;

function TPopperJS.PackJS: String;
begin
  if FCDN then
    Result := '<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>'
  else
  begin
    PopperJS_1;
    PopperJS_2;
    PopperJS_3;
    PopperJS_4;
    PopperJS_5;
    PopperJS_6;
    PopperJS_7;
    PopperJS_8;
    Result := FPack.Text;
  end;
end;

end.
